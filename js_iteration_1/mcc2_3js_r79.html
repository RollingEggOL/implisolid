<html>
<head>
<meta charset="utf-8"/>
</head>

<style>
.stat-panel{
    position:fixed;
    top:0px;
    right:0px;
    width:100px;
    /* z-index:1000; */
}
</style>

<body>
<canvas id="my_canvas"></canvas>


<!--
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r77/three.js">
</script> -->
<!--script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.js">
</script-->
<!--<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.js">
</script>-->

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.js">
</script>

<script type="text/javascript" src="./three_r79.js">
</script>


<!-- <script type="text/javascript" src="./three-r77.js"></script> -->

<!--script type="text/javascript" src="https://raw.githubusercontent.com/mrdoob/three.js/69079243426506ed86d0d0ea71b4fdda9dbb2f88/examples/js/controls/OrbitControls.js"></script
-->
<!-- Refused to execute script '...' because its MIME type ('text/plain') is not executable, and strict MIME type checking is enabled.
-->

<script>
    function assert(cond, message) {
        if (!cond) {
            console.error(message);
            throw new Exception("assert ", message);
        }
    }
    function _expect(cond, message) {
        if (!cond) {
            console.error(message);
        }
    }
</script>

<script>
/**  Asynchronously does a series of calls to the function  update_mc(). */
var callMultipleTimes = function() {
    // private:
    var last_active = 0;
    var intervals_counter = 0;

    function function_body(newPolygonizer, update_callback, burst_count, interval_msec) {
        /** Asynchronously does a series of calls to the function  update_callback().
        Previous name: update_mc_mul tiple() */


        var BURST_COUNT = burst_count; //2; // 50;
        var INTERVAL_MSEC = interval_msec; //8-1; //40  // 1   // in Milliseconds
        // Works well on too small values of INTERVAL_MSEC (Semaphore).
        // The main algorithm performs much faster when this interval is larger (>100). Becasue of `gc`.


        var already_busy_doing_it=0;  // semaphore. (Refractory). Fast x1.
        var burst_counter = 0;

        intervals_counter++;
        if(intervals_counter>1) //dont start if there is already one running
        {
            intervals_counter--;
            return;
        }
        last_active = setInterval (
            function()
            {
                if(!last_active)
                    console.error("!last_active");

                burst_counter++; // mc_icounter

                console.error(BURST_COUNT);
                if(burst_counter<BURST_COUNT)  //This code is amazingly similar to Bursting dyamics in neurons.
                {

                    if(already_busy_doing_it<1) //removable
                    {
                        already_busy_doing_it++;

                        update_callback(newPolygonizer, 0.2/10.*5 /5.);

                        if(already_busy_doing_it>1)
                            console.error(">>>already_busy_doing_it:"+already_busy_doing_it);
                        if(!last_active)
                            console.error("!last_active");
                        already_busy_doing_it--;
                    }else{
                        console.log("hit");
                    }
                }
                else
                {
                    // The interval has finished its job. Time to go.
                    if(!last_active)
                        console.error("!last_active");
                    clearInterval(last_active); // But then don't we need to wait until the last one is finished?
                    intervals_counter--; // Allow next one in future
                    burst_counter = 0;
                    last_active = 0;
                }
            },
            INTERVAL_MSEC
        );
    }
    return function_body;
}();

</script>

<!--script type="text/javascript" src="./ww_geometry77.js"></script-->
<script type="text/javascript" src="../js_iteration_2/geometry79.js"></script>
<!--<script type="text/javascript" src="../js_iteration_2/geometry73.js"></script>-->

<script>
// Default (mock) OrbitControl to void breaking the program if the orbitcontrol is not found.
THREE.OrbitControls = function() {
    this.target = new THREE.Vector3();
    this.addEventListener = function(){};
}
</script>

<script type="text/javascript" src="./controls/OrbitControls_r79.js"></script>

<!-- <script type="text/javascript" src="../js_iteration_2/bbox_calculations.js"></script> -->

<!--<body>-->
This file uses ImpliSolid's Geometry class. (unlike <a href="mcc2_3js.html">mcc2_3js.html</a>)

<br>

<script>
    'use strict';

    const THREEJS_R71 = "r71";
    const THREEJS_R77 = "r77";
    const THREEJS_R79 = "r79";

    const threejs_rev = THREEJS_R79;

    var produce_object;
    var main;

    function init_polygonizer()
    {
        //too late for pre-run
        //Module.preRun.push(letmeknow,memoryprofiler_add_hooks, letmeknow = function (){console.log("ok");});
        //Module={preRun:[letmeknow, memoryprofiler_add_hooks]};

        //main = Module.cwrap('main', 'number', []);

        // produce_object = Module.cwrap('produce_object_old2', null, ['number', 'number', 'number', 'number', 'number']);

        var newProducer={};
        newProducer.build_geometry = Module.cwrap('build_geometry', null, [ 'string', 'string']);
        newProducer.get_v_size = Module.cwrap('get_v_size', 'number', []);
        newProducer.get_f_size = Module.cwrap('get_f_size', 'number', []);
        newProducer.get_v = Module.cwrap('get_v', null, ['number']);
        newProducer.get_f = Module.cwrap('get_f', null, ['number']);
        newProducer.get_v_ptr = Module.cwrap('get_v_ptr', 'number', []);
        newProducer.get_f_ptr = Module.cwrap('get_f_ptr', 'number', []);
        newProducer.finish_geometry = Module.cwrap('finish_geometry', null, []);


        newProducer.set_object = Module.cwrap('set_object', null, ['string', 'number']);
        newProducer.unset_object = Module.cwrap('unset_object', null, []);
        newProducer.set_x = Module.cwrap('set_x', 'number', ['number', 'number']);
        newProducer.unset_x = Module.cwrap('unset_x', null, []);
        newProducer.calculate_implicit_values = Module.cwrap('calculate_implicit_values', null, []);
        newProducer.get_values_ptr = Module.cwrap('get_values_ptr', 'number', []);
        newProducer.get_values_size = Module.cwrap('get_values_size', 'number', []);
        newProducer.calculate_implicit_gradients = Module.cwrap('calculate_implicit_gradients', null, []);
        newProducer.get_gradients_ptr = Module.cwrap('get_gradients_ptr', 'number', []);
        newProducer.get_gradients_size = Module.cwrap('get_gradients_size', 'number', []);

        newProducer.get_pointset_ptr = Module.cwrap('get_pointset_ptr', 'number', ['string']);
        newProducer.get_pointset_size = Module.cwrap('get_pointset_size', 'number', ['string']);

        newProducer.about = Module.cwrap('about', null, []);

        newProducer.init = function(){ newProducer.needs_deallocation = false; }
        newProducer.finish_with = function (){
            //after the last round.
            if(!newPolygonizer.needs_deallocation)
                console.error("cannot `finish_geometry()`. Geometry not produced.");

            //todo: try-catch
            //d(1);
            newPolygonizer.finish_geometry();
            newPolygonizer.needs_deallocation = false;
            //todo(sohail):  Why newPolygonizer is used here? We should use 'this'.
        }
        newProducer.set_vect = function (float32Array){
            if (float32Array.length % 3 != 0) {console.error("bad input array");};
            var nverts = float32Array.length / 3;
            const _FLOAT_SIZE = Float32Array.BYTES_PER_ELEMENT;
            var verts_space = Module._malloc(_FLOAT_SIZE*3*nverts);
            Module.HEAPF32.subarray(verts_space/_FLOAT_SIZE, verts_space/_FLOAT_SIZE + 3*nverts).set(float32Array);
            var result = this.set_x(verts_space, nverts);
            console.log("set_x() result: "+result);
            Module._free( verts_space );
        }

        newProducer.update_geometry = function(geometry, ignoreNormals) {

            var implicit_service = this;
            const _FLOAT_SIZE = Float32Array.BYTES_PER_ELEMENT;
            const _INT_SIZE = Uint32Array.BYTES_PER_ELEMENT;
            const POINTS_PER_FACE = 3;

            var nverts = implicit_service.get_v_size();
            var nfaces = implicit_service.get_f_size();

            if(nfaces > 0){
                var verts_address = implicit_service.get_v_ptr();
                var faces_address = implicit_service.get_f_ptr();

                var verts = Module.HEAPF32.subarray(
                    verts_address/_FLOAT_SIZE,
                    verts_address/_FLOAT_SIZE + 3*nverts);

                var faces = Module.HEAPU32.subarray(
                    faces_address/_INT_SIZE,
                    faces_address/_INT_SIZE + nfaces * POINTS_PER_FACE);
            }
            else{
                console.log("empty implicit");
                var verts = new Float32Array([0,0,0, 1,0,0, 1,1,0, 0,1,0, 0,0,1, 1,0,1, 1,1,1, 0,1,1 ]);
                var faces = new Uint32Array([0,1,2, 0,2,3, 0,4,5, 0,5,1, 1,5,6, 1,6,2, 2,6,3, 3,6,7, 4,5,6, 5,6,7]);
            }

            return geometry.update_geometry1(verts, faces, ignoreNormals, false);
        };

        newProducer.init();

        //console.log("ok");
        return newProducer;
    }

</script>

<script>
'use strict';
function setShapeMatrix2Eye(shape_matrix, sz) {
    if (typeof sz == "undefined")
        sz = 1.0;

    for(var ii=0; ii<16; ii++) {
        shape_matrix[0] = 0;
    }

    shape_matrix[0] = 1 * sz;
    shape_matrix[5] = 1 * sz;
    shape_matrix[10] = 1 * sz;
    shape_matrix[15] = 1;

    shape_matrix[3] = 0;
    shape_matrix[7] = 0;
    shape_matrix[11] = 0;
}
</script>

<script>
    var MP5_GENERIC_EXAMPLE_MOON = {
       "printerSettings":{
            "name":"test",  "layerThickness":0.2, "emptyLayer":0, "infillSpace":4, "topThickness":0.6, "paramSamples":75,
            "speedRate":1000, "circleSpeedRate":1000, "temperature":220, "inAirSpeed":7000, "flowRate":0.035,
            "criticalLength":35, "retractionSpeed":2400, "retractionLength":5, "shellNumber":3, "material":"PLA 2.85mm",
            "autoZScar":true, "zScarGap":0.5, "critLayerTime":6, "filamentDiameter":2.85 },
       "mp5-version":"0.3",
       "root":{
          "type":"root",
          "children":[
             {
                "type":"Difference",
                "protected":false,
                "children":[
                   {
                      "type":"cylinder",
                      "displayColor":{ "x":0.77, "y":0.04, "z":0.18 },
                      "matrix":[ 42.5, 0, 0, 0, 0, 49.6, 0, 0, 0, 0, 10, 0, 0, 0, 0, 1 ],
                      "index":652818
                   },
                   {
                      "type":"Difference",
                      "protected":false,
                      "children":[
                         {
                            "type":"cylinder",
                            "displayColor":{"x":0.82, "y":0.66, "z":0.74 },
                            "matrix":[10, 0, 0, 0, 0, 10, 0, 0, 0, 0, 10, 0, 0, 0, 0, 1],
                            "index":1272174
                         },
                         {
                            "type":"cylinder",
                            "displayColor":{"x":0.11, "y":0.076,"z":0.63 },
                            "matrix":[10, 0, 0, 0.66, 0, 10, 0, 6.22, 0, 0, 10, 0.00001, 0, 0, 0, 1 ],
                            "index":2463576
                         }
                      ],
                      "displayColor":{ "x":0.66, "y":0.45, "z":0.72 },
                      "matrix":[2.38, 0, 0, 0.36, 0, 2.38, 0, 0.56, 0, 0, 2.38, 6.9, 0, 0, 0, 1],
                      "index":413872
                   }
                ],
                "displayColor":{"x":0.55, "y":0.07, "z":0.12 },
                "matrix":[ 1, 0, 0, 0.33, 0, 1, 0, 0.156, 0, 0, 1, 0.000000000000014, 0, 0, 0, 1],
                "index":6565922
             }
          ]
       }
    };
    var sz0 = 100.0;
    var HEART = '{"printerSettings":{"name":"test","layerThickness":0.2,"emptyLayer":0,"infillSpace":4,"topThickness":0.6,"paramSamples":75,"speedRate":1000,"circleSpeedRate":1000,"temperature":220,"inAirSpeed":7000,"flowRate":0.035,"criticalLength":35,"retractionSpeed":2400,"retractionLength":5,"shellNumber":3,"material":"PLA 2.85mm","autoZScar":true,"zScarGap":0.5,"critLayerTime":6,"filamentDiameter":2.85},"mp5-version":"0.3","root":{"type":"root","children":[{"type":"Union","protected":false,"children":[{"type":"cylinder","displayColor":{"x":0.9661750055896976,"y":0.8085857086202395,"z":0.41578037212168595},"matrix":[10,0,0,-3.7368777450135866,0,10,0,-1.9559832356144682,0,0,10,1.7323194345664206e-7,0,0,0,1],"index":7575510},{"type":"cube","displayColor":{"x":0.23399071378141634,"y":0.31584816496653323,"z":0.35457351563365425},"matrix":[10,0,0,1.867397834493545,0,10,0,-1.7325527119763677,0,0,10,-9.734106853898084e-10,0,0,0,1],"index":5587759},{"type":"cylinder","displayColor":{"x":0.43814645627496795,"y":0.39556472441055845,"z":0.3415798414286939},"matrix":[10,0,0,1.8694799105200275,0,10,0,3.688535947590836,0,0,10,-1.7225853365943067e-7,0,0,0,1],"index":6657333}],"initialSize":{"x":1,"y":1,"z":1},"displayColor":{"x":0.6470588235294118,"y":0.2784313725490196,"z":0.5882352941176471},"matrix":[10.0,0,0,82.63768850593796,0,10.0,0,126.37324151118989,0,0,10.0,5.000000079354265,0,0,0,1],"index":4872526}]}}';
    HEART = JSON.parse(HEART);
    setShapeMatrix2Eye(HEART.root.children[0].matrix, sz0);
    HEART = JSON.stringify(HEART);

    var MOON = '{"printerSettings":{"name":"test","layerThickness":0.2,"emptyLayer":0,"infillSpace":4,"topThickness":0.6,"paramSamples":75,"speedRate":1000,"circleSpeedRate":1000,"temperature":220,"inAirSpeed":7000,"flowRate":0.035,"criticalLength":35,"retractionSpeed":2400,"retractionLength":5,"shellNumber":3,"material":"PLA 2.85mm","autoZScar":true,"zScarGap":0.5,"critLayerTime":6,"filamentDiameter":2.85},"mp5-version":"0.3","root":{"type":"root","children":[{"type":"Difference","protected":false,"children":[{"type":"cylinder","displayColor":{"x":0.7675997200783986,"y":0.03892568708507049,"z":0.1754374135888661},"matrix":[35,0,0,0,0,35,0,0,0,0,9,0,0,0,0,1],"index":652818},{"type":"Difference","protected":false,"children":[{"type":"cylinder","displayColor":{"x":0.8122645344236872,"y":0.657334404743416,"z":0.7357336310755096},"matrix":[10,0,0,0,0,10,0,0,0,0,10,0,0,0,0,1],"index":1272174},{"type":"cylinder","displayColor":{"x":0.11421729990684737,"y":0.07562705374348999,"z":0.6324600862122098},"matrix":[10,0,0,0.658889604636343,0,10,0,6.215549332615993,0,0,10,1.3327027659215673e-7,0,0,0,1],"index":2463576}],"initialSize":{"x":1,"y":1,"z":1},"displayColor":{"x":0.6627450980392157,"y":0.4549019607843137,"z":0.7215686274509804},"matrix":[2.381193509886417,0,0,0.3600215429489424,0,2.381193509886417,0,0.5604901669421452,0,0,2.381193509886417,6.9059681360437395,0,0,0,1],"index":413872}],"initialSize":{"x":1,"y":1,"z":1},"displayColor":{"x":0.5529411764705883,"y":0.06666666666666667,"z":0.11764705882352941},"matrix":[1,0,0,0.32938436512727,0,1,0,0.15604124684634,0,0,1,0.000000000000014,0,0,0,1],"index":6565922}]}}';

</script>
<script>
    'use strict';
    //'use asm';

    //'use strict';

    //Version 1 has flaws: _free()s before returning the verts.
    //var CALL_VERSION = 2; //1 or 2
    const VERBOSE = false;

    //todo: reaplce _FLOAT_SIZE with Float32Array.
    //const _FLOAT_SIZE = 4;  //Float32Array.BYTES_PER_ELEMENT
    //const _INT_SIZE = 4;

    var global_time = 0;




'use strict';

// const MESH_SCALE = 300/10;
const MESH_SCALE = 1.0;
const ARROWS_COUNT = 20*10;

var global_mp5 = "***";

function provide_input (subjective_time, is_update_mode) {
    // is_update_mode: 0 => init
    // is_update_mode: 1 => update
    // is_update_mode: 2 => deprecated (used in make_geometry_old1() )

    // asked for:
    var shape_json, polygonization_json;
    const DONT_CHANGE = false;  // should be false

    if (DONT_CHANGE || is_update_mode == 0) {
        var r = subjective_time;

        // var ellipsoid_radius = 8.0 * 0.1; // r;
        var ellipsoid_radius = 8.0; // r;
        var sphere_dict1 = {
            type: "ellipsoid",
            //radius: subjective_time,
            matrix:[
                ellipsoid_radius, 0,0, 0,
                0,ellipsoid_radius, 0, 0,
                0,0,ellipsoid_radius * 0.5 ,  0,
                0,0,0,   1]
        };
        var sphere_dict = {
            type: "Union",
            matrix:[
                1, 0,0, 0,
                0,1, 0, 0,
                0,0,1,  0,
                0,0,0,   1],
            children: [sphere_dict1, sphere_dict1]
        };
        //global_mp5 = mp5_json_0;
        var mp5_json_sphere_dict= JSON.parse(JSON.stringify(MP5_GENERIC_EXAMPLE_MOON));
        mp5_json_sphere_dict.root.children=[sphere_dict];
        var SPHERE = JSON.stringify(mp5_json_sphere_dict);
        console.log(SPHERE);

        var tetrahedron_dict = {
            type: "tetrahedron",
            corners: [[0, 0, 5],[0, 10, 0],[10, 0, 0],[0, 0, -5]],
            matrix:[
                1, 0,0, 0,
                0,1, 0, 0,
                0,0,1,  0,
                0,0,0,   1]
        };
        var mp5_json_tetrahedron_dict= JSON.parse(JSON.stringify(MP5_GENERIC_EXAMPLE_MOON));
        mp5_json_tetrahedron_dict.root.children=[tetrahedron_dict];
        var TETRAHEDRON = JSON.stringify(mp5_json_tetrahedron_dict);


        // Select the object to display

        // var mp5_json = HEART;     const BB_SIZE = 9;
        var mp5_json = MOON;         const BB_SIZE = 9+9;
        // var mp5_json = TETRAHEDRON;  const BB_SIZE = 9;
        // var mp5_json = SPHERE;  const BB_SIZE = 9;

        var shape_dict = JSON.parse(mp5_json).root.children[0];
        console.log(shape_dict);

        if(is_update_mode == 0) {
            var sz = 1.;
        } else {
            var sz = r;
        }
        /*
        HEART.root.children[0].matrix[0] = sz;
        HEART.root.children[0].matrix[5] = sz;
        HEART.root.children[0].matrix[10] = sz;
        */

        // Scale the object
        shape_dict.matrix[0] = sz;
        shape_dict.matrix[5] = sz;
        shape_dict.matrix[10] = sz;

        /*
            // Move the object
            shape_dict.matrix[3] = 0;
            shape_dict.matrix[7] = 0;
            shape_dict.matrix[11] = 0;
        */

        if(false) {
            setShapeMatrix2Eye(shape_dict.matrix);
        }

        //var bb = getBoundingBoxForTree();


        mp5_json = JSON.stringify(shape_dict);

        global_mp5 = mp5_json;



        var x0=0, y0=0, z0=0;
        //var BB_SIZE = 18;
        //const BB_SIZE = 9;
        var mc_properties_json = JSON.stringify({
            resolution: Math.floor(28/2*2/2 ),
            box: {xmin: x0-BB_SIZE, xmax: x0+BB_SIZE, ymin: y0-BB_SIZE , ymax: y0+BB_SIZE, zmin: z0-BB_SIZE, zmax: z0+BB_SIZE},
            ignore_root_matrix: false,

            vresampl: {iters: 3, c: 1.0},
            projection: {enabled: 1},
            qem: {enabled: 1},

            debug: {
                enabled_pointsets:1
                // only_rank
            },


            // bug: When vresampl.iters is large, the centroid projection projects into 0 (0,0,0)
        });


        shape_json = mp5_json;
        polygonization_json = mc_properties_json;

        var tuple = [shape_json, polygonization_json];
        return tuple;
    }

    //Alternatively, use a growing sphere only.
    if(is_update_mode == 1 || is_update_mode == 2) {
        //d("2   G.");
        var x0=0, y0=0, z0=0;
        const BB_SIZE = 9;

        var r = subjective_time * 5;
        //var BB_SIZE = 6.;
        var mc_properties_json = JSON.stringify({
            resolution: 14*2 / 2 * 2,  // 28,
            box: {xmin: x0-BB_SIZE, xmax: x0+BB_SIZE, ymin: y0-BB_SIZE , ymax: y0+BB_SIZE, zmin: z0-BB_SIZE, zmax: z0+BB_SIZE},
            ignore_root_matrix: false,


            // makes things very slow
            vresampl: {iters: 1, c: 1.0},
            projection: {enabled: 1},
            qem: {enabled: 1},


        });
        //newPolygonizer.build_geometry( 28, mc_properties_json, "sphere", subjective_time);
        /*
        var mp5_json = JSON.stringify({
            type: "ellipsoid",
            //radius: r, //boudbl_mushroom only
            matrix:[
                r, 0,0, x0,
                0,r, 0, y0,
                0,0, r, z0,
                0,0,0,   1]
        });

        shape_json = mp5_json;
        */

        var d = JSON.parse(global_mp5);
        var updated_size = r / 10.;
        d.matrix[0] = updated_size;
        d.matrix[5] = updated_size;
        d.matrix[10] = updated_size;
        shape_json = JSON.stringify(d);;
        // shape_json = global_mp5;
        polygonization_json = mc_properties_json;

        //global_mp5 is not updated here. It is the original object before the update.
        var tuple = [shape_json, polygonization_json];
        return tuple;

    }

    /*
    if(is_update_mode == 2) {
        //not used anymore
        //console.log(newPolygonizer);
        //d("2   G..");
        var x0=0, y0=0, z0=0;
        var r = subjective_time;
        var mc_properties_json = JSON.stringify({
            resolution: 28,
            box: {xmin: x0-1, xmax: x0+1, ymin: y0-1 , ymax: y0+1, zmin: z0-1, zmax: z0+1}
        });
        var mp5_json = JSON.stringify({
            type: "egg",
            //radius: 3.0,  //double_mushroom only
            matrix:[
                r, 0,0, x0,
                0,r, 0, y0,
                0,0,r,  z0,
                0,0,0,   1]
        });
        shape_json = mp5_json;
        polygonization_json = mc_properties_json;
        var tuple = [shape_json, polygonization_json];
        return tuple;
    }
    */

}
/*
Three ways:
1-  make_geometry_oldold()
2-  make_geometry_old1()
3-  make_geometry_new2()
*/

function make_geometry_new2(newPolygonizer, shape_json, polygonization_json, reusable_geometry, re_allocate_buffers)
{
    //console.log(shape_json);
    //console.log(polygonization_json);


    // reusable_geometry is not used;
    var startTime = new Date();

    if(newPolygonizer.needs_deallocation) {  // Remove data from last round.
        //console.log("newPolygonizer.needs_deallocation " + newPolygonizer.needs_deallocation);
        //d(1);
        newPolygonizer.finish_geometry();
        newPolygonizer.needs_deallocation = false;
    }
    else{
        //console.error("Should not get here");
        //newPolygonizer.finish_geometry();
        //newPolygonizer.needs_deallocation = false;
    }
    //newPolygonizer.finish_geometry();

    //d("2   G");
    //28*2 --> 27 sec    28->3.75--7 msec?


    //////////////////////
    //var mp5_json = "";
    //var mc_properties_json = "";

    //newPolygonizer.build_geometry( 28, mc_properties, "sphere", subjective_time);
    //newPolygonizer.build_geometry( mp5_json , mc_properties_json);
    try{
        newPolygonizer.build_geometry( shape_json , polygonization_json);
    } catch(e) {
        console.error(e);
        Module={};  // avoids calling Module.dynCall_vii(), etc.
    }
        //implicit_double_mushroom center will be zero.

    newPolygonizer.needs_deallocation = true;

    var nverts = newPolygonizer.get_v_size();
    var nfaces = newPolygonizer.get_f_size();
    if(VERBOSE){
        console.log(nverts);
    }

    var verts_address = newPolygonizer.get_v_ptr();
    var faces_address = newPolygonizer.get_f_ptr();
    //no need to free anymore!

    const _FLOAT_SIZE = Float32Array.BYTES_PER_ELEMENT;
    var verts = Module.HEAPF32.subarray(verts_address/_FLOAT_SIZE, verts_address/_FLOAT_SIZE + 3*nverts);
    const _INT_SIZE = Uint32Array.BYTES_PER_ELEMENT;
    var faces = Module.HEAPU32.subarray(faces_address/_INT_SIZE, faces_address/_INT_SIZE + 3*nfaces);

    //verts[2] -= 0.1;
    //verts[2 + nverts*3-3] += 0.3;

    //var geom = new WGeometry77(verts, faces);
    //var geom = new MyBufferGeometry77(verts, faces, re_allocate_buffers);
    if(threejs_rev === THREEJS_R71) {
        var geom = new LiveBufferGeometry71(verts, faces, re_allocate_buffers);
    } else if(threejs_rev === THREEJS_R77) {
        var geom = new MyBufferGeometry77(verts, faces, re_allocate_buffers);
    } else if(threejs_rev === THREEJS_R79) {
        //LiveBufferGeometry79( verts_, faces_,  pre_allocate_, min_faces_capacity_, min_verts_capacity_)
        var min_faces_capacity_ = 0, min_verts_capacity_ = 0;
        var geom = new LiveBufferGeometry79(
            verts, faces,
            re_allocate_buffers,
            min_faces_capacity_, min_verts_capacity_);

        //geom.update_geometry(newPolygonizer, true);
        newPolygonizer.update_geometry(geom, true);
    }

    if(VERBOSE){
        console.log("nverts : "+ nverts);
        console.log("nfaces : "+ nfaces);
    }

    var endTime = new Date();
    var timeDiff = endTime - startTime;
    //console.log("Time: "+timeDiff+ " msec.");

    report_time(timeDiff, function(){hist();});

    return geom;
}

function get_emc_array(verts_address, point_count) {
    // var verts_address = newPolygonizer.get_pointset_ptr(name);
    // var point_count = newPolygonizer.get_pointset_size(name);

    const _FLOAT_SIZE = Float32Array.BYTES_PER_ELEMENT;
    var float_array = Module.HEAPF32.subarray(verts_address/_FLOAT_SIZE, verts_address/_FLOAT_SIZE + 1 * point_count);
    // console.error(float_array);
    return float_array;
}

function make_pointset(newPolygonizer, name, point_size, color_r, color_g, color_b) {

    // r79 only

    // var point_size = 15.0; // millimeters
    var scale_up = 1.0;

    point_size = point_size !== undefined? point_size : 15.0;

    color_r = color_r !== undefined? color_r : 0.9;
    color_g = color_g !== undefined? color_g : 0.9;
    color_b = color_b !== undefined? color_b : 0.9;

    // var dx = Math.random() * 1.0 * scale_up * 1;
    // var dy = Math.random() * 1.0 * scale_up * 1;
    // var dz = Math.random() * 1.0 * scale_up * 1;

    // var dx = 1.0 * scale_up * 1;
    // var dy = 1.0 * scale_up * 1;
    // var dz = 1.0 * scale_up * 1;
    var dx = 0, dy = 0, dz = 0;

    /*
    var verts_address = newPolygonizer.get_pointset_ptr(name);
    var point_count = newPolygonizer.get_pointset_size(name);

    const _FLOAT_SIZE = Float32Array.BYTES_PER_ELEMENT;
    var verts = Module.HEAPF32.subarray(verts_address/_FLOAT_SIZE, verts_address/_FLOAT_SIZE + 3 * point_count);
    */
    var point_count = newPolygonizer.get_pointset_size(name);
    var verts = get_emc_array(newPolygonizer.get_pointset_ptr(name), 3 * point_count );
    // console.error(verts);


    var geometry = new THREE.BufferGeometry();
    var positions = verts; //new Float32Array( point_count * 3 );

    var colors = new Float32Array( point_count * 3 );
    for ( var i = 0; i < positions.length; i += 3 ) {
        positions[ i     ] = positions[ i     ] * scale_up + dx;
        positions[ i + 1 ] = positions[ i + 1 ] * scale_up + dy;
        positions[ i + 2 ] = positions[ i + 2 ] * scale_up + dz;
    }

    for ( var i = 0; i < positions.length; i += 3 ) {
        colors[ i ]     = color_r;
        colors[ i + 1 ] = color_g;
        colors[ i + 2 ] = color_b;
    }

    geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
    geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
    geometry.computeBoundingSphere();

    //geometry is ready

    var material = new THREE.PointsMaterial( { size: point_size, vertexColors: THREE.VertexColors } );
    var points = new THREE.Points( geometry, material );

    return points;
}

function make_lines_mesh_v1(verts12, indices12, color) {

    if (indices12.length == 0) {
        console.error("Warning: indices12.length =", indices12.length);
    }
    var re_allocate_buffers;
    //var geom = new LiveBufferGeometry79( verts12, indices12, re_allocate_buffers=true, 0, 0);
    var geom = new LiveBufferGeometry79( new Float32Array(new ArrayBuffer(0)), new Uint32Array(new ArrayBuffer(0)), re_allocate_buffers=true, 0, 0);
    geom.update_geometry1(verts12, indices12, true, true);


    var wireframe_material = new THREE.MeshBasicMaterial( {
        color: color, wireframe: true, opacity:0.9,  transparent: true,} );
    var wire_msh = new THREE.Mesh(geom, wireframe_material);
    return wire_msh;
}

function make_empty_lines_mesh() {
    return new THREE.LineSegments(new THREE.BoxGeometry(0.33333,0.3333333,0.33333333));
}

function make_vectorfield_flow_lines_v1(newPolygonizer, name1, name2, point_size) {
    // works!
    // vector field flow
    /*
    var color_r, color_g, color_b;
    color_r = color_r !== undefined? color_r : 0.9;
    color_g = color_g !== undefined? color_g : 0.9;
    color_b = color_b !== undefined? color_b : 0.9;
    */

    var verts1 = get_emc_array(newPolygonizer.get_pointset_ptr(name1)+120*3*4*0, 3 * newPolygonizer.get_pointset_size(name1) + 0  );
    var verts2 = get_emc_array(newPolygonizer.get_pointset_ptr(name2)+120*3*4*0, 3 * newPolygonizer.get_pointset_size(name2) + 0 );

    var n1 = verts1.length / 3;
    var n2 = verts2.length / 3;

    if (n1 == 0) {
        return make_empty_lines_mesh();
    }
    /*
    n1 = 4*10;
    n2 = 4*10;
    var debug_mode = true;
    verts1 = verts1.subarray(0, n1 * 3);
    verts2 = verts2.subarray(0, n2 * 3);
    */

    var raw_buffer = new ArrayBuffer( Float32Array.BYTES_PER_ELEMENT * (n1 + n2) * 3);
    var verts12 = new Float32Array(raw_buffer);
    // var verts12 = new Float32Array(n1 + n2);
    verts12.subarray(0, n1 * 3).set(new Float32Array(verts1));
    verts12.subarray(n1 * 3, (n1+n2) * 3).set(new Float32Array(verts2));  // deliberate bug for TDD

    /*
    for( var i=0; i<n2; i++) {
        var b = (i+n1)*3;
        verts12[b + 0] += (Math.random()*2-1)*10;
        verts12[b + 1] += (Math.random()*2-1)*10;
        verts12[b + 2] += (Math.random()*2-1)*10;
    }
    */


    if (n1 !== n2) {
        console.error("Need to have the same number of elements.");
    }

    /*
    // I don't use a geometry mesh with wiredframe. I use a LineSegments that uses a BufferGeometry

    var raw_buffer = new ArrayBuffer( Uint32Array.BYTES_PER_ELEMENT * (n1) * 2 );
    var indices12 = new Uint32Array(raw_buffer);
    for (var i=0; i < n1; i++) {
        indices12[i * 2] = i;
        indices12[i * 2 + 1] = i ; //+ n1;  //i+1; //i + n1;
        // indices12[i * 2] = 0;
        // indices12[i * 2 + 1] = i;
    }
    */




    var raw_buffer = new ArrayBuffer( Uint32Array.BYTES_PER_ELEMENT * (n1) * 3 );
    var indices12 = new Uint32Array(raw_buffer);
    for (var i=0; i < n1; i++) {
        indices12[i * 3] = i;
        indices12[i * 3 + 1] = i + n1; //i + n1;
        indices12[i * 3 + 2] = i; //i + n1;
    }
    assert(indices12.length == n1 * 3);


    var wire_msh = make_lines_mesh_v1(verts12, indices12, 0xffffff);

    /*
    var line_material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
    var wire_msh = new THREE.LineSegments(geom, line_material);
    */
    return wire_msh;
}


function make_vectorfield_flow_lines_v2(newPolygonizer, name1, name2, point_size) {
    // vector field flow. Without using LiveGEometry (and using LineSegments)

    // does not work
    /*
    var color_r, color_g, color_b;
    color_r = color_r !== undefined? color_r : 0.9;
    color_g = color_g !== undefined? color_g : 0.9;
    color_b = color_b !== undefined? color_b : 0.9;
    */



    /*

                var positions = [];
                var next_positions_index = 0;
                var colors = [];
                var indices_array = [];
    */

    var verts1 = get_emc_array(newPolygonizer.get_pointset_ptr(name1), 3 * newPolygonizer.get_pointset_size(name1) );
    var verts2 = get_emc_array(newPolygonizer.get_pointset_ptr(name2), 3 * newPolygonizer.get_pointset_size(name2) );

    var n1 = verts1.length / 3;
    var n2 = verts2.length / 3;

    assert(n1 > 0);

    var raw_buffer = new ArrayBuffer( Float32Array.BYTES_PER_ELEMENT * (n1 + n2) * 3);
    var verts12 = new Float32Array(raw_buffer);
    // var verts12 = new Float32Array(n1 + n2);
    verts12.subarray(0, n1 * 3).set(new Float32Array(verts1));
    verts12.subarray(n1 * 3, (n1+n2) * 3).set(new Float32Array(verts2));  // deliberate bug for TDD


    if (n1 !== n2) {
        console.error("Need to have the same number of elements.");
    }

    // I don't use a geometry mesh with wiredframe. I use a LineSegments that uses a BufferGeometry

    var raw_buffer = new ArrayBuffer( Uint16Array.BYTES_PER_ELEMENT * (n1) * 2 );
    var indices12 = new Uint16Array(raw_buffer);
    for (var i=0; i < n1; i++) {
        indices12[i * 2] = i;
        indices12[i * 2 + 1] = i + n1;  //i+1; //i + n1;
    }


    var raw_buffer = new ArrayBuffer( Float32Array.BYTES_PER_ELEMENT * (n1) * 3 );
    var colors_ta = new Float32Array(raw_buffer);
    for (var i=0; i < n1; i++) {
        colors_ta[i * 3] = (i/10.0) % 1.0;
        colors_ta[i + 3 + 1] = (i/10.0) % 1.0;
        colors_ta[i + 3 + 2] = (i/10.0) % 1.0;
    }

    // var indices12 = new Uint16Array( indices_array );
    // var verts12 = new Float32Array( positions );
    // var colors_ta = new Float32Array( colors );

    var geom = new THREE.BufferGeometry();
    geom.setIndex( new THREE.BufferAttribute( indices12, 1 ) );
    geom.addAttribute( 'position', new THREE.BufferAttribute( verts12, 3 ) );
    geom.addAttribute( 'color', new THREE.BufferAttribute( colors_ta, 3 ) );
    geom.computeBoundingSphere();

    // var line_material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
    var line_material = new THREE.MeshBasicMaterial( {
        color: 0xffffff, wireframe: true, opacity:0.8,  transparent: true,} );
    var wire_msh = new THREE.LineSegments(geom, line_material);

    return wire_msh;
}



function make_normals(newPolygonizer, shape_json, pointset_label, alpha1, alpha2, color) {
    /*
        Draws lines from alpha1*grad to alpha2*grad.
        alpha1,2 are the start and end of the lines parallel to the gradients. Most likely negative alpha values are used.
        alpha=0 means points specified from the pointset specified by label pointset_label. Using color.
        Example: alpha1=0.0 and alpha2=-1.0 will draw normals (outwards). color = 0x88ff00;
    */


    // todo: refactor
    var n = newPolygonizer.get_pointset_size(pointset_label);
    var verts = get_emc_array(newPolygonizer.get_pointset_ptr(pointset_label),
        n * 3 );

    if (n == 0) {
        console.warn("Error: zero points", n);
        return make_empty_lines_mesh();
    }

    // verts = arrow_bases

    // see update_arrows()

    var ignore_root_matrix = false;
    var mp5_str = shape_json;
    console.error(mp5_str);
    newPolygonizer.set_object(mp5_str, ignore_root_matrix);
    newPolygonizer.set_vect(verts);
    newPolygonizer.calculate_implicit_gradients();

    const _FLOAT_SIZE = Float32Array.BYTES_PER_ELEMENT;
    var ptr = newPolygonizer.get_gradients_ptr();
    var ptr_len = newPolygonizer.get_gradients_size();
    var gradients = Module.HEAPF32.subarray(
        ptr/_FLOAT_SIZE, ptr/_FLOAT_SIZE + ptr_len);
    assert(ptr_len == n*3);

    for (var i = 0; i < n; ++i) {
        var r = Math.sqrt(gradients[i*3 + 0] * gradients[i*3 + 0] + gradients[i*3 + 1] * gradients[i*3 + 1] + gradients[i*3 + 2] * gradients[i*3 + 2]);
        gradients[i*3 + 0] /= r;
        gradients[i*3 + 1] /= r;
        gradients[i*3 + 2] /= r;
    }

    var raw_buffer = new ArrayBuffer( n * 3 * Float32Array.BYTES_PER_ELEMENT);
    var arrow_tips = new Float32Array(raw_buffer);
    var raw_buffer = new ArrayBuffer( n * 3 * Float32Array.BYTES_PER_ELEMENT);
    var arrow_bases = new Float32Array(raw_buffer);
    for (var i = 0; i < n; ++i) {
        for (var d = 0; d < 3; d++) {
            var j = (i * 3) + d;
            arrow_tips[j] = verts[j] + alpha2 * gradients[j];
            arrow_bases[j] = verts[j] + alpha1 * gradients[j];
        }
    }

    /*
    tuple = verts12indices12(arrow_bases, arrow_tips, n);
    indices12 = tuple[0];
    verts12 = tuple[1];
    */

    // repeated code
    var raw_buffer = new ArrayBuffer( Float32Array.BYTES_PER_ELEMENT * (n + n) * 3);
    var verts12 = new Float32Array(raw_buffer);
    verts12.subarray(0, n * 3).set(new Float32Array(arrow_bases));
    verts12.subarray(n * 3, (n+n) * 3).set(new Float32Array(arrow_tips));  //

    //repeated code
    var raw_buffer = new ArrayBuffer( Uint32Array.BYTES_PER_ELEMENT * (n) * 3 );
    var indices12 = new Uint32Array(raw_buffer);
    for (var i=0; i < n; i++) {
        indices12[i * 3] = i;
        indices12[i * 3 + 1] = i + n; //i + n;
        indices12[i * 3 + 2] = i + n; //i + n;
    }
    assert(indices12.length == n * 3);

    var wire_msh = make_lines_mesh_v1(verts12, indices12, color)

    newPolygonizer.unset_x();
    newPolygonizer.unset_object();
    return wire_msh;
}

function my_assert(cond, text){if(!cond){console.error("ASSERT FAILED: "); if(text) console.log(text);}}

//unload
function update_reused_geometry(newPolygonizer, mp5_json, mc_properties_json, geometry) {

    //console.log(mp5_json);
    //console.log(mc_properties_json);

    var startTime = new Date();

    //console.log(newPolygonizer.needs_deallocation);
    if(newPolygonizer.needs_deallocation) {  // Remove data from last round.
        //d(1);
        newPolygonizer.finish_geometry();
        newPolygonizer.needs_deallocation = false;
    }

    if(newPolygonizer.needs_deallocation)
        console.error("not deallocated.");
    try{

        newPolygonizer.build_geometry( mp5_json , mc_properties_json);
            //implicit_double_mushroom center will be zero.

        newPolygonizer.needs_deallocation = true;
    }catch(err){
        console.error("An error occured during MCC C++")
        console.info(err);
    }finally {
    }

    var ignore_normals = false
    geometry. update_geometry (newPolygonizer, ignore_normals);

    var endTime = new Date();
    var timeDiff = endTime - startTime;
    //console.log(nv3 + " , " + nf3);
    //console.log("Time: "+timeDiff+ " msec.");

    report_time(timeDiff);
}

'use strict';


//*************** Arrow Functions ****************************
/*
function make_arrow(){
    // Create an arrow and add it to the scene.
    var dir  = new THREE.Vector3( 10, 4, 0);
    var origin = new THREE.Vector3(0, 0, 0);
    var length = 10;
    var hex = 0xffff00;

    var arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
    scene.add(arrowHelper);
    console.log("Arrow");
    return arrowHelper;
}
*/

function make_multiple_arrows(n) {
    /**
     * Create an arrow and add it to the scene.
     */
    var arrowHelpers = [];
    for(var i=0;i<n;i++) {
        var dir  = new THREE.Vector3( 10, 4, 0);
        var origin = new THREE.Vector3(0, 0, 0);
        var length = 10;
        var hex = 0xffff00;

        var arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
        scene.add(arrowHelper);
        arrowHelpers.push(arrowHelper);
        console.log("Arrow");
    }
    return arrowHelpers;
}

function update_arrows(arrows, newPolygonizer, mp5_str, n, ignore_root_matrix) {
    /**
     * Update the arrow parameters
    */

    var vlist = new Float32Array(n*3);
    for(var i=0;i<n;i++) {
        var x = MESH_SCALE*10 * (Math.random()*2 - 1.);
        var y = MESH_SCALE*10 * (Math.random()*2 - 1.);
        var z = MESH_SCALE*10 * (Math.random()*2 - 1.);
        /*vlist.push(x);
        vlist.push(y);
        vlist.push(z);*/
        vlist[i*3+0] = x;
        vlist[i*3+1] = y;
        vlist[i*3+2] = z;
    }
    //var _verts = new Float32Array([x, y, z]);
    //var _verts = new Float32Array(vlist);
    var _verts = vlist;
    assert(_verts instanceof Float32Array);

    newPolygonizer.set_object(mp5_str, ignore_root_matrix);
    newPolygonizer.set_vect(_verts);
    newPolygonizer.calculate_implicit_gradients();
    const _FLOAT_SIZE = Float32Array.BYTES_PER_ELEMENT;
    var ptr = newPolygonizer.get_gradients_ptr();
    var ptr_len = newPolygonizer.get_gradients_size();
    var g = Module.HEAPF32.subarray(ptr/_FLOAT_SIZE, ptr/_FLOAT_SIZE + ptr_len);
    //console.log("grad len = " +  ptr_len+ "  grad = " + g);  // x 4

    var dir = null;
    for(var i=0;i<n;i++) {

        //if not bush
        var x = _verts[i*3 + 0];
        var y = _verts[i*3 + 1];
        var z = _verts[i*3 + 2];

        var gx = g[i*3 + 0];
        var gy = g[i*3 + 1];
        var gz = g[i*3 + 2];
        //newPolygonizer.unset_x();
        //newPolygonizer.unset_object();


        //console.log("*****************************************")
        //console.log(arrow.position);
        //console.log("*****************************************")
        //arrow.setLength(200*Math.random());
        var l = Math.sqrt(gx*gx + gy*gy + gz*gz);
        //l = l * 100/10000;
        //console.log("l: "+l);
        var ls = MESH_SCALE*1.5;
        arrows[i].position.set(x, y, z);
        arrows[i].setLength(ls);
        // This can easily get broken. i.e. by multiplying ls.
        if (!dir) {
            dir = new THREE.Vector3( 0, 0, 0);
        }
        dir.set(-gx/l, -gy/l, -gz/l);
        arrows[i].setDirection(dir);
        //console.log("change_arrow");
    }

    newPolygonizer.unset_x();
    newPolygonizer.unset_object();
}
// **************************************************************


// global variables for meshes that are accessed and updated in the render loop, etc.
var mesh_solid;
var mesh2_tiny_box_wireframe;
var materials_list; //, material_f;
var material_wireframe;
var mesh_wireframe = null;
//var last_geometry = null;
var global_normals;

var global_arrows;

const CHOSEN_MATERIAL_INDEX = 2; //3;
    // 7 = colourful
    // 3 = ?

    //1: grayscale boring phong.
    //2: faceted. (good for debug / shape study)
    //3: colorful
    //4: semi opaque (good for debug / shape study)
    //6: striped
    //7: rainbow
    //8 is wireframe
    //9: plain white?
    //10: changing peach
    //11: changing cyan
var chosen_matrial;

const SHOW_WIREFRAME = true;
const SHOW_SOLID = true;

const PERSPECTIVE = true;

function init_scene(newPolygonizer, shape_json, polygonization_json) {

    // determins the size & location of the grid, the location of the camera, and the size of the small cube in center (reference cube).
    var GRID_CELL_SIZE = 1.0;

    scene = new THREE.Scene();

    //var WIDTH = 300, HEIGHT = 300;
    var WIDTH = window.innerWidth, HEIGHT = window.innerHeight - 200; //for memory profiler

    if (PERSPECTIVE) {
        camera = new THREE.PerspectiveCamera( 75, WIDTH / HEIGHT, 1, 10000 );
        // ( fov, aspect, near, far )
    } else {
        // Use Orthogaphic camera
        var span_per_pixel = 1.0/800.0*2000.0/30.0;
        var x0 = WIDTH/2.0*span_per_pixel;
        var y0 = HEIGHT/2.0*span_per_pixel;
        camera = new THREE.OrthographicCamera( -x0,  +x0, -y0, +y0, 1, 10000 ); // ( left, right, top, bottom, near, far )
    }

    camera.position.set(0, 0, 40*GRID_CELL_SIZE);  // 40*25; //1000;

    // Grid
    var grid = grid_bed(GRID_CELL_SIZE);
    scene.add( grid );

    materials_list = look_nice();
    chosen_matrial = materials_list[CHOSEN_MATERIAL_INDEX];
    //chosen_matrial = new THREE.MeshBasicMaterial( {
    //    color: 0xaaffff, wireframe: false, opacity:0.5,  transparent: true,
    //    side:THREE.DoubleSide } );
    //THREE.FrontSide or THREE.BackSide or  THREE.DoubleSide.

    material_wireframe = new THREE.MeshBasicMaterial( {
        color: 0xff0000, wireframe: true, opacity:0.3,  transparent: true,} );

    // //if(delta_t === undefined)
    // var delta_t = 0.2;
    // // Subjective time!
    // global_time += delta_t;


    var geometry = null;
    //geometry = new THREE.BoxGeometry( 200, 200, 200 );
    /*
    if(CALL_VERSION==1){
        //geometry = make_geometry_oldold(shape_json, polygonization_json);
    }
    else
    */
    {
        geometry = make_geometry_new2(newPolygonizer, shape_json, polygonization_json, null, true);
    }
    //last_geometry = geometry;


    if(SHOW_WIREFRAME){
        mesh_wireframe = new THREE.Mesh( geometry, material_wireframe );
        mesh_wireframe.position.set( 0, 0, 0 );
        mesh_wireframe.scale.set( MESH_SCALE, MESH_SCALE, MESH_SCALE );
        scene.add( mesh_wireframe );
    }
    //this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
    //material_f = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: false, opacity:0.4, transparent: true } );
    if(SHOW_SOLID){
        //mesh_solid = new THREE.Mesh( geometry, material_f );
        //nice ones: 2, 3,  (checked until 4)
        mesh_solid = new THREE.Mesh( geometry, chosen_matrial );
        mesh_solid.position.set( 0, 0, 0 );
        mesh_solid.scale.set( MESH_SCALE, MESH_SCALE, MESH_SCALE );
        scene.add( mesh_solid );
    }

    /*
    var points2 = make_pointset( newPolygonizer, "pre_resampling_vertices", 8.0 / 4.0,   0.9, 0.0, 0.0);  // Red: before
    scene.add( points2 );

    var points1 = make_pointset( newPolygonizer, "post_resampling_vertices", 10.0 / 4.0,   0.9, 0.9, 0.0); // Yellow: after
    scene.add( points1 );
    */

    /*
    var points2 = make_pointset( newPolygonizer, "pre_qem_verts", 2.0 / 30.0,   0.9, 0.0, 0.0);  // Red: before
    scene.add( points2 );
    */


    /*
    var points1q = make_pointset( newPolygonizer, "post_qem_verts", 2.5 / 30.0 * 6.0,   0.9, 0.9, 0.0); // Yellow: after
    scene.add( points1q );
    */




    var alpha1 = -0.3, alpha2 = -0.6;
    var norms_ = make_normals(newPolygonizer, shape_json, "post_p_centroids", alpha1, alpha2, 0x009900); //  0x00ff00  // 0x88ff00
    scene.add(norms_);
    global_normals = norms_;


    /*
    var points2 = make_pointset( newPolygonizer, "pre_p_centroids", 8.0 / 4.0*2 / 30.0,   0.9, 0.0, 0.0);  // Red: before
    // scene.add( points2 );

    var points1 = make_pointset( newPolygonizer, "post_p_centroids", 10.0 / 4.0 / 30.0,   0.9, 0.9, 0.0); // Yellow: after
    scene.add( points1 );
    */


/*
    // "Centroid Projection"'s result.
    var vectorfield = make_vectorfield_flow_lines_v1(newPolygonizer, "pre_p_centroids", "post_p_centroids");
    scene.add( vectorfield );
*/
    // "QEM"'s result.
    var vectorfield = make_vectorfield_flow_lines_v1(newPolygonizer, "pre_qem_verts", "post_qem_verts");
    scene.add( vectorfield );


    // choose what is visible and what is not
    // mesh_solid.visible = false;
    // points1.visible = false;
    //points2.visible = false;
    // mesh_wireframe.visible = false;
    // vectorfield.visiable = false;
    norms_.visible = false;
    // global_normals.visible = false;




    /*
    var points2 = make_pointset( newPolygonizer, "pre_qem_verts", 8.0 / 4.0,   0.9, 0.0, 0.0);  // Red: before
    scene.add( points2 );

    var points1 = make_pointset( newPolygonizer, "post_qem_verts", 10.0 / 4.0,   0.9, 0.9, 0.0); // Yellow: after
    scene.add( points1 );
    */

    // Show a cube in center
    var geo2 = new THREE.BoxGeometry( GRID_CELL_SIZE, GRID_CELL_SIZE, GRID_CELL_SIZE );
    mesh2_tiny_box_wireframe	 = new THREE.Mesh( geo2, material_wireframe );
    mesh2_tiny_box_wireframe	.position.set( 0, 0, 0 );
    scene.add( mesh2_tiny_box_wireframe	 );
    //mesh2_tiny_box_wireframe	.scale.set( 10, 10, 10 );


    var dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(100, 100, 50);
    scene.add(dirLight);


    var dirLight2 = new THREE.DirectionalLight(0x00ffff, 1);
    dirLight2.position.set(-100, -100, -50);
    scene.add(dirLight2);

    //var arrow = make_arrow();
    //global_arrow = arrow;
    var arrows = make_multiple_arrows(ARROWS_COUNT);
    global_arrows = arrows;

    if(VERBOSE){
        console.log("RENDERER");
    }
    var render_canvas = document.getElementById( 'my_canvas' );
    console.log(render_canvas);
    renderer = new THREE.WebGLRenderer( { antialias: true, canvas: render_canvas } );
    //renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setSize( WIDTH, HEIGHT );

    document.body.appendChild( renderer.domElement );


    /*
      function callMultipleTimes() {
            var mc_icounter=0;
            setInterval(function(){ if(mc_icounter<10) update_mc(newPolygonizer, 0.2/10.*5); mc_icounter++; }, 30);
        }
    */


    function doKeyDownListener(event) {
        if ( event.keyCode == 17 ) {

            var BURST_COUNT = 5; // 50;
            var INTERVAL_MSEC = 100; // 8-1; //40  // 1   // in Milliseconds

            //update_mc(newPolygonizer);
            callMultipleTimes (newPolygonizer, update_mc, BURST_COUNT, INTERVAL_MSEC);
            //change_arrow(arrow, newPolygonizer, global_mp5);
        }
        else
            console.log(event.keyCode);
    }
    window.addEventListener( "keydown", doKeyDownListener, false );  // keydown  keypress


    // CONTROLS
    //see https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_teapot.html
    var cameraControls = new THREE.OrbitControls( camera, renderer.domElement );

    cameraControls.rotateSpeed = 1.5;
    cameraControls.zoomSpeed = 1.2;
    cameraControls.panSpeed = 0.8;
    cameraControls.enableZoom = true;
    cameraControls.enablePan = true;
    cameraControls.enableDamping = true;
    cameraControls.dampingFactor = 0.6; //0.9; // 1.0; //motile: 0.3;

    /*
  cameraControls.constraint.smoothZoom = true;
    cameraControls.constraint.zoomDampingFactor = 0.2;
    cameraControls.constraint.smoothZoomSpeed = 5.0;
    */


    cameraControls.target.set( 0, 0, 0 );
    cameraControls.addEventListener( 'change', function () {;} );



}

function update_mc(newPolygonizer, delta_t){

    if(delta_t === undefined)
        delta_t = 0.2;
    // Subjective time!
    global_time += delta_t;

    var tuple = provide_input(global_time, 1);
    var shape_json = tuple[0];
    var polygonization_json = tuple[1];


    //Three modes of speed here for (UPDATE_SAME_GEOM_OBJECT, EVEN_REUSE_MESH_OBJECT):
    //  (false, false) // Creates a new Geometry object at each loop iteration.
    //  (true, false)  // Keeps geometry object instance
    //  (true, true)   // Keeps mesh instance (as well as geometry)

    var UPDATE_SAME_GEOM_OBJECT = true;  //Will not even call the constructor
    var EVEN_REUSE_MESH_OBJECT = true;
    if( EVEN_REUSE_MESH_OBJECT && ! UPDATE_SAME_GEOM_OBJECT)
        console.error("Wrong condition.");

    if(SHOW_SOLID){
        var p1 = [mesh_solid.position, mesh_solid.rotation];
    }
    if(SHOW_WIREFRAME){
        var p2 = [mesh_wireframe.position, mesh_wireframe.rotation];
    }

    // g   i.e.  actual_current_active_geom
    var g = null;
    if(SHOW_SOLID){
        g = mesh_solid.geometry;
    }
    if(SHOW_WIREFRAME){
        g = mesh_wireframe.geometry;
    }
    my_assert(g, "SHOW_SOLID  and  SHOW_WIREFRAME cannot be both false.");


    if(!EVEN_REUSE_MESH_OBJECT){
        if(SHOW_SOLID){
            scene.remove(mesh_solid);
        }
        if(SHOW_WIREFRAME){
            scene.remove(mesh_wireframe);
        }
    }

    var reused_last_geom = g;

    //Not sure about the condision
    if(!UPDATE_SAME_GEOM_OBJECT){
        if(SHOW_SOLID){
            g.dispose();
            g = null;
            // reused_last_geom is not null and will remain. It is not recommended to use reused_last_geom.
        }
        //mesh_wireframe.geometry.dispose(); // Don't do it twice!
    }

    // var reused_last_geom = g;
    if(!EVEN_REUSE_MESH_OBJECT){
        mesh_solid = null;
        mesh_wireframe = null;
    }

    var geometry = null;
    if(UPDATE_SAME_GEOM_OBJECT) {
        geometry = g;
        //update_reused_geometry(newPolygonizer, global_time, geometry);
        // shape_json: from update,
        update_reused_geometry(newPolygonizer, shape_json, polygonization_json, geometry);
    }
    else {
        /*
        if(CALL_VERSION==1){
            //geometry = make_geometry_oldold(shape_json, polygonization_json);
        }
        else
        */
        {
            //reused_last_geom = null;
            geometry = make_geometry_new2(newPolygonizer, shape_json, polygonization_json, null, false);  //FALSE??
        }
    };
    /*
    "";
    for(var i=0;i<10*3;i++){
        //geometry.attributes.position.setXYZ( i, x, y, z );
        geometry.attributes.position.array[i] += 0.0002 * (i% 2);
        //geometry.index.array[ i ] += (i % 2)*40 ;
        var nverts = geometry.attributes.position.count/3;
        geometry.index.array[ i ] = (geometry.index.array[ i ] % (nverts));
    }
    //geometry.attributes.position.needsUpdate = true;
    //geometry.index.needsUpdate = true;
    "";
    */

    /*
    // SLOW. But using -o3 compilation it can make a nice live smooth QEM demo.
    if (global_normals) {
        scene.remove(global_normals);
        global_normals = null
    }
    var alpha = 60.0;
    var norms_ = make_normals(newPolygonizer, global_mp5, "post_p_centroids", 0, alpha, 0x009900); //  0x00ff00  // 0x88ff00
    scene.add(norms_);
    global_normals = norms_;
    */

    /*
    var ignore_root_matrix = false;

    update_arrows(global_arrows, newPolygonizer, global_mp5, ARROWS_COUNT, ignore_root_matrix);
    */


    if(!EVEN_REUSE_MESH_OBJECT){
        if(SHOW_WIREFRAME){
            mesh_wireframe = new THREE.Mesh( geometry, material_wireframe );
            mesh_wireframe.scale.set( MESH_SCALE, MESH_SCALE, MESH_SCALE );
            //copy so that we dont lose the rotation, position of the meshes.
            mesh_wireframe.position.copy(p2[0]);
            mesh_wireframe.rotation.copy(p2[1]);
            scene.add( mesh_wireframe );
        }


        /*var material1 = new THREE.MeshPhongMaterial( {
                            color: 0xaaaaaa, specular: 0xffffff, shininess: 250,
                            side: THREE.DoubleSide, vertexColors: THREE.VertexColors
                        } );

        mesh_solid = new THREE.Mesh( geometry, material1 );
        */
        if(SHOW_SOLID){
            mesh_solid = new THREE.Mesh( geometry, chosen_matrial );
            //   //mesh_solid.position.set( 0, 0, 0 );
            mesh_solid.scale.set( MESH_SCALE, MESH_SCALE, MESH_SCALE );
            mesh_solid.position.copy(p1[0]);
            mesh_solid.rotation.copy(p1[1]);
            scene.add( mesh_solid );

        }
    }
}

/**
    Stuff to make things look pretty.
    Taken from http://threejs.org/examples/#webgl_materials
*/
function generateTexture() {
    var canvas = document.createElement( 'canvas' );
    //var canvas = document.getElementById( 'my_canvas' );
    canvas.width = 256;
    canvas.height = 256;
    var context = canvas.getContext( '2d' );
    var image = context.getImageData( 0, 0, 256, 256 );
    var x = 0, y = 0;
    for ( var i = 0, j = 0, l = image.data.length; i < l; i += 4, j ++ ) {
        x = j % 256;
        y = x == 0 ? y + 1 : y;
        image.data[ i ] = 255;
        image.data[ i + 1 ] = 255;
        image.data[ i + 2 ] = 255;
        image.data[ i + 3 ] = Math.floor( x ^ y );
    }
    context.putImageData( image, 0, 0 );
    return canvas;
}

function grid_bed(step) {
    assert(step > 0.0 && "Grid step has to be non zero");
    // var step = 25;
    var y_floor =  step * -3;  // -75;
    var ngrids = 40;
    var span = step * ngrids;  // 1000;
    //note: span/step == ngrids
    var line_material = new THREE.LineBasicMaterial( { color: 0x303030 } );
    var _geometry = new THREE.Geometry();
    for ( var i = 0; i <= ngrids; i++ ) {

        var v = i*step-span/2;

        _geometry.vertices.push( new THREE.Vector3( -span/2,   y_floor,    v ) );
        _geometry.vertices.push( new THREE.Vector3( +span/2,    y_floor,    v ) );

        _geometry.vertices.push( new THREE.Vector3( v, y_floor, -span/2 ) );
        _geometry.vertices.push( new THREE.Vector3( v, y_floor, +span/2 ) );
    }
    if(threejs_rev == THREEJS_R71) {
        throw new Error("Grid: to be implemented on r71- where THREE.LineSegments() does not exist");
    }
    var grid_lines = new THREE.LineSegments( _geometry, line_material );
    return grid_lines;
}
function look_nice(){
    var materials = [];

    // Materials
    var texture = new THREE.Texture( generateTexture() );
    texture.needsUpdate = true;
    materials.push( new THREE.MeshLambertMaterial( { map: texture, transparent: true } ) );
    materials.push( new THREE.MeshLambertMaterial( { color: 0xdddddd, shading: THREE.FlatShading } ) );
    materials.push( new THREE.MeshPhongMaterial( { color: 0xdddddd, specular: 0x009900, shininess: 30,
        shading: THREE.FlatShading,
        side:THREE.DoubleSide,
        opacity: 0.99, transparent: true,
        } ) );

    materials.push( new THREE.MeshNormalMaterial( ) );
    materials.push( new THREE.MeshBasicMaterial( { color: 0xffaa00, transparent: true, blending: THREE.AdditiveBlending } ) );
    //materials.push( new THREE.MeshBasicMaterial( { color: 0xff0000, blending: THREE.SubtractiveBlending } ) );
    materials.push( new THREE.MeshLambertMaterial( { color: 0xdddddd, shading: THREE.SmoothShading } ) );
    materials.push( new THREE.MeshPhongMaterial( { color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.SmoothShading, map: texture, transparent: true } ) );
    materials.push( new THREE.MeshNormalMaterial( { color: 0x00dd00,  shading: THREE.SmoothShading,
        //opacity:0.5,  transparent: true, side:THREE.DoubleSide
    } ));
    materials.push( new THREE.MeshBasicMaterial( { color: 0xffaa00, wireframe: true } ) );
    materials.push( new THREE.MeshDepthMaterial() );
    materials.push( new THREE.MeshLambertMaterial( { color: 0x666666, emissive: 0xff0000, shading: THREE.SmoothShading } ) );
    materials.push( new THREE.MeshPhongMaterial( { color: 0x000000, specular: 0x666666, emissive: 0xff0000, shininess: 10, shading: THREE.SmoothShading, opacity: 0.9, transparent: true } ) );
    materials.push( new THREE.MeshBasicMaterial( { map: texture, transparent: true } ) );
    return materials;
}


var time_queue = [];
var time_queue__last_timeout = 0;
function report_time(time_msec, callback){
    time_queue.push(time_msec);
    if(time_queue__last_timeout){
        clearTimeout(time_queue__last_timeout);
        time_queue__last_timeout = 0;
    }
    time_queue__last_timeout = setTimeout(function(){
        console.log("Time: (msec)");
        console.log(time_queue);
        if(callback)
            callback();
        time_queue = [];
        time_queue__last_timeout =0;
    }, 1000);
}
function animate() {

    requestAnimationFrame( animate );

    //Updating the meshes
    var SPEED = 0 * 3. / 100;
    if(mesh_wireframe){
        mesh_wireframe.rotation.x += 0.01*SPEED;
        mesh_wireframe.rotation.y += 0.02*SPEED;
    }
    if(mesh_solid){
        mesh_solid.rotation.x += 0.01*SPEED;
        mesh_solid.rotation.y += 0.02*SPEED;
    }

    mesh2_tiny_box_wireframe	.rotation.z += 0.01*SPEED;
    mesh2_tiny_box_wireframe	.rotation.y += 0.02*SPEED;

    //Updating the matrials

    //material update callback
    //materials_list[ materials_list.length - 2 ].emissive.setHSL( 0.54, 1, 0.35 * ( 0.5 + 0.5 * Math.sin( 35 * global_time / 20. ) ) );
    //materials_list[ materials_list.length - 3 ].emissive.setHSL( 0.04, 1, 0.35 * ( 0.5 + 0.5 * Math.cos( 35 * global_time / 20.) ) );

    renderer.render( scene, camera );

}

var scene, camera, renderer;
//var geometry;

//var newPolygonizer; //no longer global. Hopefully does not affect the performance.
window.setTimeout(
    // function() {
    //     var newPolygonizer = init_polygonizer();
    //     init_scene(newPolygonizer);
    //     animate();
    // },
3000);

</script>

<!--script type="text/javascript" src="wwexample1.js"></script-->
<script type="text/javascript">
if(0){
//worker example
if (window.Worker) {
    var myWorker = new Worker("wwexample1.js");
    myWorker.postMessage({a:3, b:6});
    myWorker.postMessage({a:8, b:9});
    myWorker.onmessage = function(e) {
        console.log('I received this from worker');
        //console.log(e);
        console.log(e.data);

        /*
    bubbles    : false
    cancelBubble    : false
    cancelable    : false
    currentTarget    : Worker
    data    : Object
    defaultPrevented    : false
    eventPhase    : 0
    isTrusted    : true
    isTrusted    : true
    lastEventId    : ""
    origin    : ""
    path    : Array[0]
    ports    : Array[0]
    returnValue    : true
    source    : null
    srcElement    : Worker
    target    : Worker
    timeStamp    : 1555.6200000000001
    type    : "message"

        */

    }
}
else{
    console.warning("Your browser does not support WebWorkers. See http://stackoverflow.com/questions/4739916/what-browsers-currently-support-web-workers ");
}
}
</script>

<!-- Graph -->
<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
<!--<div id="chart_div" style="width: 900px; height: 500px;"></div>-->

<script>
var ggraph = 0;
function show_hist(data_array){
    if(ggraph==0){
        add_graph_div();
        google.charts.load("current", {packages:["corechart"]});
    }
    google.charts.setOnLoadCallback(drawChart);
    function drawChart() {
        var data = google.visualization.arrayToDataTable(data_array);
        var options = {
            title: 'Time ( Milliseconds )',
            legend: { position: 'none' },
            colors: ['#e7711c'],
            histogram: {
                bucketSize: 1,
                //maxNumBuckets: 200,
                //minValue: -1,
                //maxValue: 200
            },
            //chartArea: { width: 401 },
            hAxis: {
              //ticks: [-1, 0,1,2,3,4,5,6,7,8,9,10,12,14,20,30,40,50,60,80,100,120,140,160,180,200],
              //ticks: [ -1, 0,1,2,3,4,5,6,7,8,9,10,11,12 ],
              //Array.from(Array(10).keys())
              //[...Array(10).keys()]
              ticks: (Array.from(Array(30*1.).keys())).map(function(x){return x/1.;}, Number),
            },
            //vAxis: { scaleType: 'mirrorLog' }
        };
        //see https://developers.google.com/chart/interactive/docs/gallery/histogram#controlling-buckets
        var div_element = document.getElementById('chart_div');
        console.log(div_element);
        var chart = new google.visualization.Histogram(div_element);
        chart.draw(data, options);
    }
    ggraph++;
}

var global_histogram_accumulator = [];
function hist_delayed() {
    var a = time_queue;
    //var q = [];
    if(global_histogram_accumulator.length==0){
        global_histogram_accumulator.push(["Time"]);
    }
    var UPPER_BOUND = 12;
    for(var i=0;i<a.length;i++){
        if(a[i]<=UPPER_BOUND)
            global_histogram_accumulator.push([a[i]*1.]); //The precision of the timing is 1 msec :(
    }
    show_hist(global_histogram_accumulator);
}

function hist(){
    //hist_delayed();
}

//setTimeout(function()}{
function add_graph_div(){
    //<div id="chart_div" style="width: 900px; height: 500px;"></div>
    //var elemDiv = document.createElement('div');
    //document.body.appendChild(elemDiv);
    //not nice:
    //document.body.innerHTML += "<div id=\"chart_div\" style=\"width: 900px; height: 500px;\"></div>";
}

</script>

<!--
To show the histogram: Uncomment the following <div> to reveal the histogram graph, also uncomment the line that says: //hist_delayed();
-->

<div id="chart_div" class="stat-panel" no_style="width: 900px; height: 500px;">
</div>


<script>
    var implisolid = {};
    // The code that runs immediately after finishing loading of the Emscripten-generated js.
    function set_off() {
        console.log("ready.");
        var newPolygonizer = init_polygonizer();
        implisolid = newPolygonizer;

        //if(delta_t === undefined)
        var delta_t = 0.2;
        // Subjective time!
        global_time += delta_t;

        var tuple = provide_input(global_time, 0);
        var shape_json = tuple[0];
        var polygonization_json = tuple[1];

        init_scene(newPolygonizer, shape_json, polygonization_json);
        animate();
    };
</script>

<!-- Memory profiler code by "jj" from https://groups.google.com/forum/#!topic/emscripten-discuss/HtAzVposlX4 -->
<script type="text/javascript" src="./lib/memoryprofiler.js"></script>
<script>
        //function letmeknow(){console.log("Loading memory profiler");}
        Module={preRun:[
            letmeknow=function (){console.log("Loading memory profiler");},
            // memoryprofiler_add_hooks
        ],
        onRuntimeInitialized: set_off,
    };
</script>
<script type="text/javascript" src="mcc2.compiled.js"></script>
