<html>
<head>
<meta charset="utf-8"/>
</head>
<!-- Memory profiler code by "jj":
from https://groups.google.com/forum/#!topic/emscripten-discuss/HtAzVposlX4
-->
<script type="text/javascript" src="memoryprofiler.js"></script>
<script>
        //function letmeknow(){console.log("Loading memory profiler");}
        Module={preRun:[
            letmeknow=function (){console.log("Loading memory profiler");},
            memoryprofiler_add_hooks
        ]};

</script>
<body>
<script type="text/javascript" src="mcc2.cpp.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r77/three.js"></script>
<!--script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.js"></script-->

<!--script type="text/javascript" src="https://raw.githubusercontent.com/mrdoob/three.js/69079243426506ed86d0d0ea71b4fdda9dbb2f88/examples/js/controls/OrbitControls.js"></script
-->
<!-- Refused to execute script '...' because its MIME type ('text/plain') is not executable, and strict MIME type checking is enabled.
-->
<!--script type="text/javascript" src="./ww_geometry77.js"></script-->
<script type="text/javascript" src="./geometry77.js"></script>

<script type="text/javascript" src="./controls/OrbitControls.js"></script>

<!--<body>-->
Based on MCC1

<br>

<script>
    'use strict';
    //var newProducer;
    function init_polygonizer()
    {
        //too late for pre-run
        //Module.preRun.push(letmeknow,memoryprofiler_add_hooks, letmeknow = function (){console.log("ok");});
        //Module={preRun:[letmeknow, memoryprofiler_add_hooks]};

        main = Module.cwrap('main', 'number', []);

        produce_object = Module.cwrap('produce_object', null, ['number', 'number', 'number', 'number', 'number']);

        var newProducer={};
        newProducer.build_geometry = Module.cwrap('build_geometry', null, ['number', 'number']);
        newProducer.get_v_size = Module.cwrap('get_v_size', 'number', []);
        newProducer.get_f_size = Module.cwrap('get_f_size', 'number', []);
        newProducer.get_v = Module.cwrap('get_v', null, ['number']);
        newProducer.get_f = Module.cwrap('get_f', null, ['number']);
        newProducer.finish_geometry = Module.cwrap('finish_geometry', null, []);

        //console.log("ok");
        return newProducer;
    }

</script>
<script>
    'use strict';
    //'use asm';

    //'use strict';

    //Version 1 has flaws: _free()s before returning the verts.
    var CALL_VERSION = 2; //1 or 2
    const VERBOSE = false;

    var WIREFRAME = false;
    var produce_object;
    var main;


    //const DBLFLOAT_SIZE = 8;
    const _FLOAT_SIZE = 4;  //Float32Array.BYTES_PER_ELEMENT
    const _INT_SIZE = 4;
    //4 int
    //4 float
    //4 long

    var global_time = 0;

    /* old style. This leaves memory footprints (memory leak) */
    function do_vf_old(delta_t)
    {
        //var time = 0.2;
        global_time += delta_t;

        //var max_verts = 40000;  // *2
        //var max_faces = 15000;  //*5

        var max_verts = 16000;  // *2
        var max_faces = 13000;  //*5
        var verts_address = Module._malloc(_FLOAT_SIZE*3*max_verts);
        var nv_address = Module._malloc(_INT_SIZE*1);
        var faces_address = Module._malloc(_INT_SIZE*3*max_faces)
        var nf_address = Module._malloc(_INT_SIZE*1);
        //todo: how to make sure enough space is allocated.


        /* ************************* */
        /*   Call C++                */
        produce_object(verts_address, nv_address, faces_address, nf_address, global_time);
        /* ************************* */

        //Module.HEAPF64 is a Float64Array
        var nverts = Module.HEAPU32[nv_address/_INT_SIZE];
        var nfaces = Module.HEAPU32[nf_address/_INT_SIZE];
        var verts = Module.HEAPF32.subarray(verts_address/_FLOAT_SIZE, verts_address/_FLOAT_SIZE + 3*nverts);
        var faces = Module.HEAPU32.subarray(faces_address/_INT_SIZE, faces_address/_INT_SIZE + 3*nfaces);
        //what if there is not enough memory?

        //         var result_faces = new Float32Array(dataHeap.buffer, dataHeap.byteOffset, data.length);
        //verts_address is byteOffset?

        //second attemtps: (still has problems)
        var result_verts = new Float32Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + verts_address, 3*nverts * _FLOAT_SIZE);

        //Thisrd solution:
        //http://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html

        var h_len = (Module.HEAPF32.length);
        var v_end=(verts_address/_FLOAT_SIZE + 3*nverts);
        var f_end = (faces_address/_INT_SIZE + 3*nfaces);
        if(h_len <= v_end || h_len <= f_end)
            console.error("Insufficient heap: "+(h_len - v_end)+ " , "+(h_len - f_end));
        else
            console.info("Heap size OK.");

        //console.log(Module.HEAPF32.subarray(verts_address/_FLOAT_SIZE, verts_address/_FLOAT_SIZE + 3*2));

        //console.log("subarray");
        //console.log(verts.subarray(verts.length-100, verts.length));

        // ****************************
        // The actual leak was here !
        // ****************************
        //freeing resources
        //also see http://kapadia.github.io/emscripten/2013/09/13/emscripten-pointers-and-pointers.html
        Module._free(verts_address);
        Module._free(nv_address);
        Module._free(faces_address);
        Module._free(nf_address);

        //BUG! Accessed (returned) after "_Free"ing.
        // FIXME: FREED before actually copying

        //console.log(Module.HEAPF32.subarray(verts_address/_FLOAT_SIZE, verts_address/_FLOAT_SIZE + 3*2));
        //console.log(result_verts.subarray(0, 3*2));

        if(VERBOSE){
            console.log("nverts : "+ nverts);
            console.log("nfaces : "+ nfaces);
        }

        return [verts, faces];
        //return [result_verts, faces];
    }

//    //third way:
//    function     vf(){
//            //function _produce_object($verts,$nv,$faces,$nf,$time){}
//
//  // $verts = $verts|0;
//  // $nv = $nv|0;
//  // $faces = $faces|0;
//  // $nf = $nf|0;
//  // $time = +$time;
//  //$254 = $verts..
//  //HEAPF32[$254>>2] = $251;
//  //
//    }
function make_geometry_old(delta_t)
{

    var startTime = new Date();
    //new Date().getTime()

    if(delta_t === undefined)
        delta_t = 0.2;

    vf = do_vf_old(delta_t);
    v = vf[0];
    f = vf[1];

    var endTime = new Date();
    var timeDiff = endTime - startTime;
    console.log("TIME: "+timeDiff+ " msec.");

    return new MyGeometry(v, f);
}



'use strict';

/**  Asynchronously does a series of calls to the function  update_mc(). */
var call_multiple_times = function() {
    // private:
    var last_active = 0;
    var intervals_counter = 0;

    function _call_multiple_times(newPolygonizer, update_mc) {
        /** Asynchronously does a series of calls to the function  update_mc().
        Previous name: update_mc_mul tiple() */
        var BURST_COUNT = 10;
        var INTERVAL_MSEC = 40  // 1   // in Milliseconds
            // Works well on too small values (Semaphore).
            // The main algorithm performs much faster when this interval is larger (>100). Becasue of `gc`.

        //var mc_icounter=0;
        var already_busy_doing_it=0;  // semaphore. (Refractory). Fast x1.
        var burst_counter = 0;

        //already_busy_doing_it level1: right now.
        //already_busy_doing_it: interval (level 2)

        intervals_counter++;
        if(intervals_counter>1) //dont start if there is already one running
        {
            intervals_counter--;
            return;
        }
        last_active = setInterval (
            function()
            {
                /*
                var ls="";
                for (var lft=0;lft<100;lft++){
                    ls+=" ";
                }
                console.log(ls.slice(1));
                console.log("1msec");
                return;
                */
                if(!last_active)
                    console.error("!last_active");

                burst_counter++; // mc_icounter

                if(burst_counter<BURST_COUNT)  //This code is amazingly similar to Bursting dyamics in neurons.
                {

                    if(already_busy_doing_it<1) //removable
                    {
                        already_busy_doing_it++;

                        update_mc(newPolygonizer, 0.2/10.*5 /5.);

                        if(already_busy_doing_it>1)
                            console.error(">>>already_busy_doing_it:"+already_busy_doing_it);
                        if(!last_active)
                            console.error("!last_active");
                        already_busy_doing_it--;
                    }else{
                        console.log("hit");
                    }
                }
                else
                {
                    // The interval has finished its job. Time to go.
                    if(!last_active)
                        console.error("!last_active");
                    clearInterval(last_active); // But then don't we need to wait until the last one is finished?
                    intervals_counter--; // Allow next one in future
                    burst_counter = 0;
                    last_active = 0;
                }
            },
            INTERVAL_MSEC
        );
    }
    return _call_multiple_times;
}();

/*
// MyLiveUpdatableGeometry
LiveGeometry = function () {
    //material_wireframe = ...;
    THREE.THREE.ImmediateRenderObject.call( this, material_wireframe );
    this.setVF = function(verts, faces){
    }
};
LiveGeometry.prototype = Object.create( THREE.Geometry.prototype );
LiveGeometry.prototype.constructor = LiveGeometry;
*/



function make_geometry_new(newPolygonizer, delta_t)
{
    var startTime = new Date();

    if(delta_t === undefined)
        delta_t = 0.2;
    // Subjective time!
    //var time = 0.2;
    global_time += delta_t;


    //console.log(newPolygonizer);
    newPolygonizer.build_geometry( 28, global_time);

    var nverts = newPolygonizer.get_v_size();
    var nfaces = newPolygonizer.get_f_size();
    if(VERBOSE){
        console.log(nverts);
    }

    var verts_address = Module._malloc(_FLOAT_SIZE*3*nverts);
    var faces_address = Module._malloc(_INT_SIZE*3*nfaces);

    newPolygonizer.get_v(verts_address, nverts);
    newPolygonizer.get_f(faces_address, nfaces);

    var verts = Module.HEAPF32.subarray(verts_address/_FLOAT_SIZE, verts_address/_FLOAT_SIZE + 3*nverts);
    //console.log(verts);
    var faces = Module.HEAPU32.subarray(faces_address/_INT_SIZE, faces_address/_INT_SIZE + 3*nfaces);

    //var geom = new MyGeometry(verts, faces);
    var geom = new WGeometry77(verts, faces);

    // Now you can free the resources.

    Module._free(verts_address);
    Module._free(faces_address);

    newPolygonizer.finish_geometry();

    if(VERBOSE){
        console.log("nverts : "+ nverts);
        console.log("nfaces : "+ nfaces);
    }

    var endTime = new Date();
    var timeDiff = endTime - startTime;
    console.log("TIME: "+timeDiff);

    return geom;
}


'use strict';

// global variables for meshes that are accessed and updated in the render loop, etc.
var mesh_solid;
var mesh2_tiny_box_wireframe;
var materials_list, material_f;
var material_wireframe, mesh_wireframe = null;
const CHOSEN_MATERIAL_INDEX = 7; //3;
    //1: grayscale boring phong.
    //2: faceted. (good for debug / shape study)
    //3: colorful
    //4: semi opaque (good for debug / shape study)
    //6: striped
    //7: rainbow
    //8 is wireframe
    //9: plain white?
    //10: changing peach
    //11: changing cyan

function init_scene(newPolygonizer) {

    scene = new THREE.Scene();

    //var WIDTH = 300, HEIGHT = 300;
    var WIDTH = window.innerWidth, HEIGHT = window.innerHeight - 200; //for memory profiler
    camera = new THREE.PerspectiveCamera( 75, WIDTH / HEIGHT, 1, 10000 );
    camera.position.z = 1000;


    materials_list = look_nice(scene);

    material_wireframe = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true, opacity:0.3,  transparent: true, } );

    //geometry = new THREE.BoxGeometry( 200, 200, 200 );
    if(CALL_VERSION==1){
        geometry = make_geometry_old();
    }
    else{
        geometry = make_geometry_new(newPolygonizer);
    }

    mesh_wireframe = new THREE.Mesh( geometry, material_wireframe );
    mesh_wireframe.position.set( 0, 0, 0 );
    //mesh_wireframe.scale.set( 10*10, 10*10, 10*10 );
    mesh_wireframe.scale.set( 300, 300, 300 );

    //mesh_wireframe.position.z = +0;
    //mesh_wireframe.rotation.y = -Math.PI * .5;

    scene.add( mesh_wireframe );
    //this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );


    material_f = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: false, opacity:0.4, transparent: true } );

    //mesh_solid = new THREE.Mesh( geometry, material_f );
    //nice ones: 2, 3,  (checked until 4)
    mesh_solid = new THREE.Mesh( geometry, materials_list[CHOSEN_MATERIAL_INDEX] );
    mesh_solid.position.set( 0, 0, 0 );
    mesh_solid.scale.set( 300, 300, 300 );
    scene.add( mesh_solid );


    var geo2 = new THREE.BoxGeometry( 20, 20, 20 );
    mesh2_tiny_box_wireframe	 = new THREE.Mesh( geo2, material_wireframe );
    mesh2_tiny_box_wireframe	.position.set( 0, 0, 0 );
    scene.add( mesh2_tiny_box_wireframe	 );
    //mesh2_tiny_box_wireframe	.scale.set( 10, 10, 10 );

    var dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(100, 100, 50);
    scene.add(dirLight);


    if(VERBOSE){
        console.log("RENDERER");
    }
    renderer = new THREE.WebGLRenderer( { antialias: true } );
    //renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setSize( WIDTH, HEIGHT );

    document.body.appendChild( renderer.domElement );


    /*
      function call_multiple_times() {
            var mc_icounter=0;
            setInterval(function(){ if(mc_icounter<10) update_mc(newPolygonizer, 0.2/10.*5); mc_icounter++; }, 30);
        }
    */


    function doKeyDownListener(event) {
        if ( event.keyCode == 17 ) {
            //update_mc(newPolygonizer);
            call_multiple_times(newPolygonizer, update_mc);
        }
        else
            console.log(event.keyCode);
    }
    window.addEventListener( "keydown", doKeyDownListener, false );  // keydown  keypress


    // CONTROLS
    //see https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_teapot.html
    var cameraControls = new THREE.OrbitControls( camera, renderer.domElement );
    cameraControls.target.set( 0, 0, 0 );
    cameraControls.addEventListener( 'change', function () {;} );

}

function update_mc(newPolygonizer, delta_t){
    var p1 = [mesh_solid.position, mesh_solid.rotation];
    var p2 = [mesh_wireframe.position, mesh_wireframe.rotation];
    scene.remove(mesh_solid);
    scene.remove(mesh_wireframe);

    var geometry;
    if(CALL_VERSION==1){
        geometry = make_geometry_old(delta_t);
    }
    else{
        geometry = make_geometry_new(newPolygonizer, delta_t);
    }


    mesh_wireframe = new THREE.Mesh( geometry, material_wireframe );
    //mesh_wireframe.position.set( 0, 0, 0 );
    mesh_wireframe.scale.set( 300, 300, 300 );
    //copy so that we dont lose the rotation, position of the meshes.
    mesh_wireframe.position.copy(p1[0]);
    mesh_wireframe.rotation.copy(p1[1]);
    scene.add( mesh_wireframe );

    mesh_solid = new THREE.Mesh( geometry, materials_list[CHOSEN_MATERIAL_INDEX] );
    //mesh_solid.position.set( 0, 0, 0 );
    mesh_solid.scale.set( 300, 300, 300 );
    mesh_solid.position.copy(p2[0]);
    mesh_solid.rotation.copy(p2[1]);
    scene.add( mesh_solid );
}

/**
    Stuff to make things look pretty.
    Taken from http://threejs.org/examples/#webgl_materials
*/
function generateTexture() {
    var canvas = document.createElement( 'canvas' );
    canvas.width = 256;
    canvas.height = 256;
    var context = canvas.getContext( '2d' );
    var image = context.getImageData( 0, 0, 256, 256 );
    var x = 0, y = 0;
    for ( var i = 0, j = 0, l = image.data.length; i < l; i += 4, j ++ ) {
        x = j % 256;
        y = x == 0 ? y + 1 : y;
        image.data[ i ] = 255;
        image.data[ i + 1 ] = 255;
        image.data[ i + 2 ] = 255;
        image.data[ i + 3 ] = Math.floor( x ^ y );
    }
    context.putImageData( image, 0, 0 );
    return canvas;
}

function look_nice(scene){
    var materials = [];
    // Grid
    var line_material = new THREE.LineBasicMaterial( { color: 0x303030 } ),
        geometry = new THREE.Geometry(),
        floor = -75, step = 25;
    for ( var i = 0; i <= 40; i ++ ) {
        geometry.vertices.push( new THREE.Vector3( - 500, floor, i * step - 500 ) );
        geometry.vertices.push( new THREE.Vector3(   500, floor, i * step - 500 ) );
        geometry.vertices.push( new THREE.Vector3( i * step - 500, floor, -500 ) );
        geometry.vertices.push( new THREE.Vector3( i * step - 500, floor,  500 ) );
    }
    var line = new THREE.LineSegments( geometry, line_material );
    scene.add( line );
    // Materials
    var texture = new THREE.Texture( generateTexture() );
    texture.needsUpdate = true;
    materials.push( new THREE.MeshLambertMaterial( { map: texture, transparent: true } ) );
    materials.push( new THREE.MeshLambertMaterial( { color: 0xdddddd, shading: THREE.FlatShading } ) );
    materials.push( new THREE.MeshPhongMaterial( { color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.FlatShading } ) );
    materials.push( new THREE.MeshNormalMaterial( ) );
    materials.push( new THREE.MeshBasicMaterial( { color: 0xffaa00, transparent: true, blending: THREE.AdditiveBlending } ) );
    //materials.push( new THREE.MeshBasicMaterial( { color: 0xff0000, blending: THREE.SubtractiveBlending } ) );
    materials.push( new THREE.MeshLambertMaterial( { color: 0xdddddd, shading: THREE.SmoothShading } ) );
    materials.push( new THREE.MeshPhongMaterial( { color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.SmoothShading, map: texture, transparent: true } ) );
    materials.push( new THREE.MeshNormalMaterial( { shading: THREE.SmoothShading } ) );
    materials.push( new THREE.MeshBasicMaterial( { color: 0xffaa00, wireframe: true } ) );
    materials.push( new THREE.MeshDepthMaterial() );
    materials.push( new THREE.MeshLambertMaterial( { color: 0x666666, emissive: 0xff0000, shading: THREE.SmoothShading } ) );
    materials.push( new THREE.MeshPhongMaterial( { color: 0x000000, specular: 0x666666, emissive: 0xff0000, shininess: 10, shading: THREE.SmoothShading, opacity: 0.9, transparent: true } ) );
    materials.push( new THREE.MeshBasicMaterial( { map: texture, transparent: true } ) );
    return materials;
}



function animate() {

    requestAnimationFrame( animate );

    //Updating the meshes
    var SPEED = 3. / 100;
    if(mesh_wireframe){
        mesh_wireframe.rotation.x += 0.01*SPEED;
        mesh_wireframe.rotation.y += 0.02*SPEED;
        mesh_solid.rotation.x += 0.01*SPEED;
        mesh_solid.rotation.y += 0.02*SPEED;
    }

    mesh2_tiny_box_wireframe	.rotation.z += 0.01*SPEED;
    mesh2_tiny_box_wireframe	.rotation.y += 0.02*SPEED;

    //Updating the matrials

    //material update callback
    //materials_list[ materials_list.length - 2 ].emissive.setHSL( 0.54, 1, 0.35 * ( 0.5 + 0.5 * Math.sin( 35 * global_time / 20. ) ) );
    //materials_list[ materials_list.length - 3 ].emissive.setHSL( 0.04, 1, 0.35 * ( 0.5 + 0.5 * Math.cos( 35 * global_time / 20.) ) );

    renderer.render( scene, camera );

}

var scene, camera, renderer;
var geometry;

//var newPolygonizer; //no longer global. Hopefully does not affect the performance.
window.setTimeout(function()
{
    var newPolygonizer = init_polygonizer();
    init_scene(newPolygonizer);
    animate();
}, 3000);


</script>
