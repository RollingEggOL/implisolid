<html>
<head>
<meta charset="utf-8"/>
</head>
<script type="text/javascript" src="memoryprofiler.js"></script>
<script>
        function letmeknow(){console.log("111111");}
        Module={preRun:[letmeknow, memoryprofiler_add_hooks]};

</script>
<body>
<script type="text/javascript" src="mcc1.cpp.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r77/three.js"></script>
<!--script type="text/javascript" src="https://raw.githubusercontent.com/mrdoob/three.js/69079243426506ed86d0d0ea71b4fdda9dbb2f88/examples/js/controls/OrbitControls.js"></script
-->
<!-- Refused to execute script '...' because its MIME type ('text/plain') is not executable, and strict MIME type checking is enabled.
-->
<script type="text/javascript" src="./controls/OrbitControls.js"></script>

<!--<body>-->
Based on MCC1

<br>

<script>
    //'use strict';

    var WIREFRAME = false;
    var produce_object;
    var main;

    function init1()
    {
        function letmeknow(){console.log("111111");}
        //Module.preRun.push(letmeknow,memoryprofiler_add_hooks,letmeknow);
        //Module={preRun:[letmeknow, memoryprofiler_add_hooks]};

        produce_object = Module.cwrap('produce_object', null, ['number', 'number', 'number', 'number', 'number']);
        main = Module.cwrap('main', 'number', []);
        console.log("ok");
    }

    var global_time = 0;

    function do_vf()
    {
        //const DBLFLOAT_SIZE = 8;
        const FLOAT_SIZE = 4;
        const INT_SIZE = 4;
        //4 int
        //4 float
        //4 long

        //var max_verts = 40000;  // *2
        //var max_faces = 15000;  //*5

        var max_verts = 6000;  // *2
        var max_faces = 3000;  //*5
        var verts_address = Module._malloc(FLOAT_SIZE*3*max_verts);
        var nv_address = Module._malloc(INT_SIZE*1);
        var faces_address = Module._malloc(INT_SIZE*3*max_faces)
        var nf_address = Module._malloc(INT_SIZE*1);
        //todo: how to make sure enough space is allocated.

        //var time = 0.2;
        global_time += 0.2;

        /* ************************* */
        /*   Call C++                */
        produce_object(verts_address, nv_address, faces_address, nf_address, global_time);
        /* ************************* */

        //Module.HEAPF64 is a Float64Array
        var nverts = Module.HEAPU32[nv_address/INT_SIZE];
        var nfaces = Module.HEAPU32[nf_address/INT_SIZE];
        var verts = Module.HEAPF32.subarray(verts_address/FLOAT_SIZE, verts_address/FLOAT_SIZE + 3*nverts);
        var faces = Module.HEAPU32.subarray(faces_address/INT_SIZE, faces_address/INT_SIZE + 3*nfaces);
        //what if there is not enough memory?

        var h_len = (Module.HEAPF32.length);
        var v_end=(verts_address/FLOAT_SIZE + 3*nverts);
        var f_end = (faces_address/INT_SIZE + 3*nfaces);
        if(h_len <= v_end || h_len <= f_end)
            console.error("Insufficient heap: "+(h_len - v_end)+ " , "+(h_len - f_end));
        else
            console.info("Heap size OK.");

        //console.log("subarray");
        //console.log(verts.subarray(verts.length-100, verts.length));

        // ****************************
        // The actual leak was here !
        // ****************************
        //freeing resources
        //also see http://kapadia.github.io/emscripten/2013/09/13/emscripten-pointers-and-pointers.html
        Module._free(verts_address);
        Module._free(nv_address);
        Module._free(faces_address);
        Module._free(nf_address);

        console.log("nverts : "+ nverts)
        console.log("nfaces : "+ nfaces)

        return [verts, faces];
    }


'use strict';

MyBufferGeometry = function ( verts, faces ) {

//MyBufferGeometry = function ( verts, faces, width, height, depth, widthSegments, heightSegments, depthSegments ) {


    //console.log(faces);
    console.log("MyBufferGeometry");

    THREE.BufferGeometry.call( this );

    //console.log("raw v size " + verts.length);
    //console.log("vl " + verts.length/3);
    //console.log("fl " + faces.length/3);

    this.type = 'MyBufferGeometry';

    this.parameters = {
        //width: width,
        //height: height,
        //depth: depth,
        //widthSegments: widthSegments,
        //heightSegments: heightSegments,
        //depthSegments: depthSegments
    };
    var vertexCount = verts.length/3;
    var facecount = faces.length/3;
    var indexCount = facecount*3;

    console.log("vertexCount="+vertexCount+ "   ,  facecount=" + facecount+ "   facecount*3="+(facecount*3));

    // buffers
    var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
    var vertices = new Float32Array( vertexCount * 3 );
    var normals = new Float32Array( vertexCount * 3 );
    var uvs = new Float32Array( vertexCount * 2 );

    // offset variables
    //var vertexBufferOffset = 0;
    //var uvBufferOffset = 0;
    //var indexBufferOffset = 0;
    //var numberOfVertices = 0;

    // group variables
    //var groupStart = 0;

    // build each side of the box geometry
    //output: vertices, normals, uvs, indices

    nans_warnings = 0;
    //console.log("vertexCount " + vertexCount)
    SCALE = 1.
    for(var i=0; i < vertexCount; i++)
    {
        for(var di = 0; di < 3; di++)
            vertices[i*3+di] = verts[i*3+di] * SCALE;
        x = verts[i*3+0];
        y = verts[i*3+1];
        z = verts[i*3+2];
        //console.log(x+" , " + y + " , " + z);

        d = Math.sqrt(x*x+y*y+z*z);
        d=d+0.;
        //if(d==0) d=1.;
        if(isNaN(d)) {
            d=1.;x=1.;y=1.;z=1.;
            console.log("Warning");
        }
        //console.log("x y z"+x+" "+y+" "+z+"   / "+ d)

        sgn = +1;
        normals[i*3 + 0] = x/d*sgn;
        normals[i*3 + 1] = y/d*sgn;
        normals[i*3 + 2] = z/d*sgn;

        if(isNaN(x/d))
            nans_warnings ++;

        d2 = Math.sqrt(x*x+y*y);
        uvs[i*2+0] = x/d2;
        uvs[i*2+1] = y/d2;
    }

    for(var i=0; i < facecount; i++)
        for(var si=0; si<3; si++)
            indices[i*3+si] = faces[i*3+si];

    //console.log(indices);

    materialIndex = 0;
    this.addGroup( 0, facecount*3, materialIndex ); //not sure about *3 . Why??

    if(nans_warnings > 0)
        console.error("WARNING: NaN in vertices. "+nans_warnings/978+" out of "+vertexCount/978+ "  subtract:"+(vertexCount-nans_warnings)/978);




    //this.addGroup( groupStart, groupCount, materialIndex );  //groupCount is same as indices' index.

    //modified, but not output: indexBufferOffset, vertexBufferOffset, uvBufferOffset, numberOfVertices, groupStart

    // build geometry
    this.setIndex( new THREE.BufferAttribute( indices, 3 ) );
    this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

    // helper functions

    function calculateVertexCount ( w, h, d ) {

        var vertices = 0;

        // calculate the amount of vertices for each side (plane)
        vertices += (w + 1) * (h + 1) * 2; // xy
        vertices += (w + 1) * (d + 1) * 2; // xz
        vertices += (d + 1) * (h + 1) * 2; // zy

        return vertices;

    }

    function calculateIndexCount ( w, h, d ) {

        var index = 0;

        // calculate the amount of squares for each side
        index += w * h * 2; // xy
        index += w * d * 2; // xz
        index += d * h * 2; // zy

        return index * 6; // two triangles per square => six vertices per square

    }

};

MyBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
MyBufferGeometry.prototype.constructor = MyBufferGeometry;


MyGeometry = function (verts, faces) {
    //vects, faces

    THREE.Geometry.call( this );

    this.type = 'ImplicitGeometry'; //?

    this.parameters = {
        /*width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments*/
    };


    //faces = faces.subarray(0, 300);
    this.fromBufferGeometry( new MyBufferGeometry( verts, faces ) );
    //this.mergeVertices();

};

MyGeometry.prototype = Object.create( THREE.Geometry.prototype );
MyGeometry.prototype.constructor = MyGeometry;



/*
// MyLiveUpdatableGeometry
LiveGeometry = function () {
    //material_wireframe = ...;
    THREE.THREE.ImmediateRenderObject.call( this, material_wireframe );
    this.setVF = function(verts, faces){
    }
};
LiveGeometry.prototype = Object.create( THREE.Geometry.prototype );
LiveGeometry.prototype.constructor = LiveGeometry;
*/

function make_geometry()
{

    var startTime = new Date();
    //new Date().getTime()



    vf = do_vf();
    v = vf[0];
    f = vf[1];

    var endTime = new Date();
    var timeDiff = endTime - startTime;
    console.log("TIME: "+timeDiff);

    return new MyGeometry(v, f);
}

mesh_wireframe = null;
function init2() {

    scene = new THREE.Scene();

    WIDTH = 300;
    HEIGHT = 300;
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;
    camera = new THREE.PerspectiveCamera( 75, WIDTH / HEIGHT, 1, 10000 );
    camera.position.z = 1000;


    materials_list = look_nice(scene);

    material_wireframe = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true, opacity:0.3,  transparent: true, } );
    if(1){
        //geometry = new THREE.BoxGeometry( 200, 200, 200 );
        geometry = make_geometry();

        mesh_wireframe = new THREE.Mesh( geometry, material_wireframe );
        mesh_wireframe.position.set( 0, 0, 0 );
        //mesh_wireframe.scale.set( 10*10, 10*10, 10*10 );
        mesh_wireframe.scale.set( 300, 300, 300 );

        //mesh_wireframe.position.z = +0;
        //mesh_wireframe.rotation.y = -Math.PI * .5;

        scene.add( mesh_wireframe );
        //this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
    }

    material_f = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: false, opacity:0.4, transparent: true } );

        //mesh_solid = new THREE.Mesh( geometry, material_f );
        //nice ones: 2, 3,  (checked until 4)
        mesh_solid = new THREE.Mesh( geometry, materials_list[3] );
        mesh_solid.position.set( 0, 0, 0 );
        mesh_solid.scale.set( 300, 300, 300 );
        scene.add( mesh_solid );


    geo2 = new THREE.BoxGeometry( 20, 20, 20 );
    mesh2_box_wireframe	 = new THREE.Mesh( geo2, material_wireframe );
    mesh2_box_wireframe	.position.set( 0, 0, 0 );
    scene.add( mesh2_box_wireframe	 );
    //mesh2_box_wireframe	.scale.set( 10, 10, 10 );

    var dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(100, 100, 50);
    scene.add(dirLight);


    console.log("RENDERER");
    renderer = new THREE.WebGLRenderer( { antialias: true } );
    //renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setSize( WIDTH, HEIGHT );

    document.body.appendChild( renderer.domElement );

    function doKeyDownListener(event){
        if ( event.keyCode == 17 ) {
            update_mc();
        }
        else
            console.log(event.keyCode);
    }
    window.addEventListener( "keydown", doKeyDownListener, false );  // keydown  keypress


    // CONTROLS
    //see https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_teapot.html
    cameraControls = new THREE.OrbitControls( camera, renderer.domElement );
    cameraControls.target.set( 0, 0, 0 );
    cameraControls.addEventListener( 'change', function () {;} );

}

function update_mc(){
    scene.remove(mesh_solid);
    scene.remove(mesh_wireframe);

    var geometry = make_geometry();

    mesh_wireframe = new THREE.Mesh( geometry, material_wireframe );
    mesh_wireframe.position.set( 0, 0, 0 );
    mesh_wireframe.scale.set( 300, 300, 300 );
    scene.add( mesh_wireframe );

    mesh_solid = new THREE.Mesh( geometry, materials_list[3] );
    mesh_solid.position.set( 0, 0, 0 );
    mesh_solid.scale.set( 300, 300, 300 );
    scene.add( mesh_solid );
}

//based on http://threejs.org/examples/#webgl_materials
function generateTexture() {
                var canvas = document.createElement( 'canvas' );
                canvas.width = 256;
                canvas.height = 256;
                var context = canvas.getContext( '2d' );
                var image = context.getImageData( 0, 0, 256, 256 );
                var x = 0, y = 0;
                for ( var i = 0, j = 0, l = image.data.length; i < l; i += 4, j ++ ) {
                    x = j % 256;
                    y = x == 0 ? y + 1 : y;
                    image.data[ i ] = 255;
                    image.data[ i + 1 ] = 255;
                    image.data[ i + 2 ] = 255;
                    image.data[ i + 3 ] = Math.floor( x ^ y );
                }
                context.putImageData( image, 0, 0 );
                return canvas;
            }

function look_nice(scene){
    var materials = [];
    // Grid
    var line_material = new THREE.LineBasicMaterial( { color: 0x303030 } ),
        geometry = new THREE.Geometry(),
        floor = -75, step = 25;
    for ( var i = 0; i <= 40; i ++ ) {
        geometry.vertices.push( new THREE.Vector3( - 500, floor, i * step - 500 ) );
        geometry.vertices.push( new THREE.Vector3(   500, floor, i * step - 500 ) );
        geometry.vertices.push( new THREE.Vector3( i * step - 500, floor, -500 ) );
        geometry.vertices.push( new THREE.Vector3( i * step - 500, floor,  500 ) );
    }
    var line = new THREE.LineSegments( geometry, line_material );
    scene.add( line );
    // Materials
    var texture = new THREE.Texture( generateTexture() );
    texture.needsUpdate = true;
    materials.push( new THREE.MeshLambertMaterial( { map: texture, transparent: true } ) );
    materials.push( new THREE.MeshLambertMaterial( { color: 0xdddddd, shading: THREE.FlatShading } ) );
    materials.push( new THREE.MeshPhongMaterial( { color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.FlatShading } ) );
    materials.push( new THREE.MeshNormalMaterial( ) );
    materials.push( new THREE.MeshBasicMaterial( { color: 0xffaa00, transparent: true, blending: THREE.AdditiveBlending } ) );
    //materials.push( new THREE.MeshBasicMaterial( { color: 0xff0000, blending: THREE.SubtractiveBlending } ) );
    materials.push( new THREE.MeshLambertMaterial( { color: 0xdddddd, shading: THREE.SmoothShading } ) );
    materials.push( new THREE.MeshPhongMaterial( { color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.SmoothShading, map: texture, transparent: true } ) );
    materials.push( new THREE.MeshNormalMaterial( { shading: THREE.SmoothShading } ) );
    materials.push( new THREE.MeshBasicMaterial( { color: 0xffaa00, wireframe: true } ) );
    materials.push( new THREE.MeshDepthMaterial() );
    materials.push( new THREE.MeshLambertMaterial( { color: 0x666666, emissive: 0xff0000, shading: THREE.SmoothShading } ) );
    materials.push( new THREE.MeshPhongMaterial( { color: 0x000000, specular: 0x666666, emissive: 0xff0000, shininess: 10, shading: THREE.SmoothShading, opacity: 0.9, transparent: true } ) );
    materials.push( new THREE.MeshBasicMaterial( { map: texture, transparent: true } ) );
    return materials;
}
function animate() {

    requestAnimationFrame( animate );


    var SPEED = 3. / 100;
    if(mesh_wireframe){
    mesh_wireframe.rotation.x += 0.01*SPEED;
    mesh_wireframe.rotation.y += 0.02*SPEED;
    mesh_solid.rotation.x += 0.01*SPEED;
    mesh_solid.rotation.y += 0.02*SPEED;
    }

    mesh2_box_wireframe	.rotation.z += 0.01*SPEED;
    mesh2_box_wireframe	.rotation.y += 0.02*SPEED;



    //materials_list[ materials.length - 2 ].emissive.setHSL( 0.54, 1, 0.35 * ( 0.5 + 0.5 * Math.sin( 35 * timer ) ) );
    //materials_list[ materials.length - 3 ].emissive.setHSL( 0.04, 1, 0.35 * ( 0.5 + 0.5 * Math.cos( 35 * timer ) ) );

    renderer.render( scene, camera );

}

var scene, camera, renderer;
var geometry, material_wireframe, mesh_wireframe;

window.setTimeout(function()
{
    init1();
    init2();
    animate();
}, 3000);


</script>
